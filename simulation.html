<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TryYomi - Precision Surgery Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 100;
        }

        .hud > * {
            pointer-events: auto;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 20px;
            padding: 20px;
            min-width: 200px;
        }

        .method-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .method-title {
            font-size: 14px;
            color: #888;
            margin-bottom: 5px;
        }

        .method-btn {
            padding: 12px 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .method-btn.active {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            color: #00ff88;
        }

        .method-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        /* Metrics */
        .metrics {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metric-label {
            font-size: 14px;
            color: #888;
        }

        .metric-value {
            font-size: 20px;
            font-weight: 600;
        }

        .metric-value.good {
            color: #00ff88;
        }

        .metric-value.warning {
            color: #ffaa00;
        }

        .metric-value.bad {
            color: #ff4444;
        }

        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 15px;
            padding: 20px 40px;
            text-align: center;
            z-index: 100;
        }

        .instruction-text {
            font-size: 16px;
            color: #00ff88;
            margin-bottom: 10px;
        }

        .controls {
            font-size: 14px;
            color: #888;
        }

        /* Target indicator */
        .target-indicator {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
        }

        .target-ring {
            position: absolute;
            border: 2px solid #00ff88;
            border-radius: 50%;
            opacity: 0.5;
            animation: pulse 2s ease-in-out infinite;
        }

        .ring-1 {
            width: 100px;
            height: 100px;
            left: -50px;
            top: -50px;
        }

        .ring-2 {
            width: 60px;
            height: 60px;
            left: -30px;
            top: -30px;
            animation-delay: 0.5s;
        }

        .ring-3 {
            width: 20px;
            height: 20px;
            left: -10px;
            top: -10px;
            animation-delay: 1s;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 0.5;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
        }

        /* Timer */
        .timer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: 700;
            color: #00ff88;
            opacity: 0;
            pointer-events: none;
            z-index: 200;
            text-shadow: 0 0 50px rgba(0, 255, 136, 0.5);
        }

        .timer.show {
            animation: timerPulse 1s ease-out;
        }

        @keyframes timerPulse {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.2);
            }
        }

        /* Results modal */
        .results-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .results-content {
            background: linear-gradient(135deg, #0a0f1b 0%, #1a1f2e 100%);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 30px;
            padding: 50px;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .results-title {
            font-size: 36px;
            font-weight: 700;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
        }

        .score-display {
            font-size: 72px;
            font-weight: 800;
            margin-bottom: 20px;
        }

        .score-breakdown {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .breakdown-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
        }

        .breakdown-label {
            font-size: 14px;
            color: #888;
            margin-bottom: 5px;
        }

        .breakdown-value {
            font-size: 24px;
            font-weight: 600;
        }

        .action-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: black;
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid #00ff88;
            color: #00ff88;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        /* Precision cursor */
        .precision-cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 2px solid #00ff88;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
        }

        .precision-cursor.freehand {
            animation: shake 0.2s infinite;
        }

        .precision-cursor.static {
            animation: shake 0.1s infinite;
        }

        .precision-cursor.yomi {
            animation: none;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-48%, -52%) rotate(1deg); }
            75% { transform: translate(-52%, -48%) rotate(-1deg); }
        }

        /* Score animation */
        .score-popup {
            position: fixed;
            font-size: 48px;
            font-weight: 700;
            pointer-events: none;
            z-index: 200;
            animation: scoreFloat 2s ease-out forwards;
        }

        @keyframes scoreFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) scale(1.5);
            }
        }
    </style>
</head>
<body>
    <!-- Auth check overlay -->
    <div id="authCheck" style="position: fixed; inset: 0; background: #000; z-index: 9999; display: flex; align-items: center; justify-content: center;">
        <div style="text-align: center;">
            <h2 style="color: #00ff88; font-size: 24px; margin-bottom: 20px;">Checking authentication...</h2>
            <div class="loading" style="margin: 0 auto;"></div>
        </div>
    </div>
    
    <canvas id="canvas"></canvas>
    
    <!-- Custom cursor -->
    <div class="precision-cursor" id="cursor"></div>
    
    <!-- HUD -->
    <div class="hud">
        <div class="hud-panel">
            <div class="method-selector">
                <div class="method-title">SURGICAL METHOD</div>
                <button class="method-btn active" onclick="setMethod('freehand')">Freehand</button>
                <button class="method-btn" onclick="setMethod('static')">Static Guided</button>
                <button class="method-btn" onclick="setMethod('yomi')">Yomi Robotic</button>
            </div>
        </div>
        
        <div class="hud-panel">
            <div class="metrics">
                <div class="metric">
                    <span class="metric-label">Angular Deviation</span>
                    <span class="metric-value" id="angleDeviation">0.00°</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Platform Deviation</span>
                    <span class="metric-value" id="platformDeviation">0.00mm</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Depth Accuracy</span>
                    <span class="metric-value" id="depthAccuracy">100%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Time Elapsed</span>
                    <span class="metric-value" id="timeElapsed">0.0s</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Target indicator -->
    <div class="target-indicator" id="targetIndicator">
        <div class="target-ring ring-1"></div>
        <div class="target-ring ring-2"></div>
        <div class="target-ring ring-3"></div>
    </div>
    
    <!-- Instructions -->
    <div class="instructions">
        <div class="instruction-text" id="instructionText">Select a method and click to begin placement</div>
        <div class="controls">Mouse: Move drill | Click: Place implant | Scroll: Adjust depth</div>
    </div>
    
    <!-- Timer -->
    <div class="timer" id="timer">3</div>
    
    <!-- Results Modal -->
    <div class="results-modal" id="resultsModal">
        <div class="results-content">
            <h2 class="results-title">Procedure Complete!</h2>
            <div class="score-display" id="scoreDisplay">95%</div>
            
            <div class="score-breakdown">
                <div class="breakdown-item">
                    <div class="breakdown-label">Method</div>
                    <div class="breakdown-value" id="methodResult">Freehand</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-label">Precision</div>
                    <div class="breakdown-value" id="precisionResult">0.5mm</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-label">Time</div>
                    <div class="breakdown-value" id="timeResult">12.3s</div>
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="btn btn-primary" onclick="tryAgain()">Try Again</button>
                <button class="btn btn-secondary" onclick="saveResults()">Save Results</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js'
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js'
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm'
        
        // Supabase configuration
        const supabaseUrl = 'https://cbopynuvhcymbumjnvay.supabase.co'
        const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNib3B5bnV2aGN5bWJ1bWpudmF5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM5OTUxNzMsImV4cCI6MjA1OTU3MTE3M30.UZElMkoHugIt984RtYWyfrRuv2rB67opQdCrFVPCfzU'
        const supabase = createClient(supabaseUrl, supabaseAnonKey)
        
        // Check authentication
        async function checkAuth() {
            try {
                const { data: { user } } = await supabase.auth.getUser()
                
                if (!user) {
                    // Not authenticated, redirect to home
                    alert('Please sign in to use the simulator')
                    window.location.href = 'index.html'
                    return false
                }
                
                // Hide auth check overlay
                document.getElementById('authCheck').style.display = 'none'
                return true
            } catch (error) {
                console.error('Auth check failed:', error)
                window.location.href = 'index.html'
                return false
            }
        }
        
        // Only initialize the game if authenticated
        checkAuth().then(isAuthenticated => {
            if (isAuthenticated) {
                initializeSimulation()
            }
        })
        
        function initializeSimulation() {
        
        // Scene setup
        const scene = new THREE.Scene()
        scene.fog = new THREE.Fog(0x000000, 10, 50)
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.set(0, 5, 8)
        
        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('canvas'),
            antialias: true,
            alpha: false
        })
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFSoftShadowMap
        renderer.toneMapping = THREE.ACESFilmicToneMapping
        renderer.toneMappingExposure = 1.2
        
        // Controls
        const controls = new OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.dampingFactor = 0.05
        controls.maxPolarAngle = Math.PI / 2.2
        controls.minDistance = 5
        controls.maxDistance = 15
        controls.target.set(0, 0, 0)
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5)
        scene.add(ambientLight)
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 1)
        mainLight.position.set(5, 10, 5)
        mainLight.castShadow = true
        mainLight.shadow.camera.near = 0.1
        mainLight.shadow.camera.far = 50
        mainLight.shadow.camera.left = -10
        mainLight.shadow.camera.right = 10
        mainLight.shadow.camera.top = 10
        mainLight.shadow.camera.bottom = -10
        mainLight.shadow.mapSize.width = 2048
        mainLight.shadow.mapSize.height = 2048
        scene.add(mainLight)
        
        const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3)
        fillLight.position.set(-5, 5, -5)
        scene.add(fillLight)
        
        // Create realistic jaw
        const jawGroup = new THREE.Group()
        
        // Jaw bone
        const jawGeometry = new THREE.TorusGeometry(3.5, 1.5, 24, 48, Math.PI)
        const jawMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xFFE4E1,
            roughness: 0.8,
            metalness: 0,
            clearcoat: 0.2,
            clearcoatRoughness: 0.9,
            bumpScale: 0.002,
        })
        
        const jaw = new THREE.Mesh(jawGeometry, jawMaterial)
        jaw.rotation.x = -Math.PI / 2
        jaw.castShadow = true
        jaw.receiveShadow = true
        jawGroup.add(jaw)
        
        // Gum tissue
        const gumGeometry = new THREE.TorusGeometry(3.3, 1.4, 24, 48, Math.PI)
        const gumMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xFFB5C5,
            roughness: 0.9,
            metalness: 0,
            clearcoat: 0.1,
            transmission: 0.1,
            thickness: 0.5,
        })
        
        const gum = new THREE.Mesh(gumGeometry, gumMaterial)
        gum.rotation.x = -Math.PI / 2
        gum.position.y = 0.1
        gum.castShadow = true
        gum.receiveShadow = true
        jawGroup.add(gum)
        
        // Create realistic teeth
        const teethGroup = new THREE.Group()
        
        function createTooth(type = 'molar') {
            let geometry
            if (type === 'molar') {
                geometry = new THREE.CylinderGeometry(0.35, 0.3, 1, 12)
            } else if (type === 'premolar') {
                geometry = new THREE.CylinderGeometry(0.3, 0.25, 1.1, 10)
            } else {
                geometry = new THREE.CylinderGeometry(0.25, 0.2, 1.2, 8)
            }
            
            // Add some realistic deformation
            const positions = geometry.attributes.position
            for (let i = 0; i < positions.count; i++) {
                const y = positions.getY(i)
                if (y > 0) {
                    const noise = (Math.random() - 0.5) * 0.05
                    positions.setX(i, positions.getX(i) + noise)
                    positions.setZ(i, positions.getZ(i) + noise)
                }
            }
            
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xFFFFF0,
                roughness: 0.2,
                metalness: 0,
                clearcoat: 1,
                clearcoatRoughness: 0.05,
                reflectivity: 0.5,
                envMapIntensity: 1,
                sheen: 0.5,
                sheenRoughness: 0.2,
                sheenColor: 0xffffff,
            })
            
            const tooth = new THREE.Mesh(geometry, material)
            tooth.castShadow = true
            tooth.receiveShadow = true
            
            return tooth
        }
        
        // Place teeth realistically
        const teethPositions = [
            { angle: 0.1, radius: 3.2, type: 'incisor' },
            { angle: 0.3, radius: 3.2, type: 'incisor' },
            { angle: 0.5, radius: 3.2, type: 'canine' },
            { angle: 0.7, radius: 3.1, type: 'premolar' },
            { angle: 0.9, radius: 3.0, type: 'premolar' },
            { angle: 1.1, radius: 2.9, type: 'molar' },
            { angle: 1.3, radius: 2.8, type: 'molar' },
            { angle: 1.8, radius: 2.8, type: 'molar' },
            { angle: 2.0, radius: 2.9, type: 'molar' },
            { angle: 2.2, radius: 3.0, type: 'premolar' },
            { angle: 2.4, radius: 3.1, type: 'premolar' },
            { angle: 2.6, radius: 3.2, type: 'canine' },
            { angle: 2.8, radius: 3.2, type: 'incisor' },
            { angle: 3.0, radius: 3.2, type: 'incisor' },
        ]
        
        teethPositions.forEach((pos, index) => {
            const tooth = createTooth(pos.type)
            tooth.position.x = Math.cos(pos.angle) * pos.radius
            tooth.position.z = Math.sin(pos.angle) * pos.radius
            tooth.position.y = 0.6
            tooth.rotation.z = (Math.random() - 0.5) * 0.1
            tooth.rotation.x = (Math.random() - 0.5) * 0.05
            
            // Skip one tooth for implant site
            if (index !== 7) {
                teethGroup.add(tooth)
            }
        })
        
        jawGroup.add(teethGroup)
        scene.add(jawGroup)
        
        // Target site marker
        const targetGeometry = new THREE.RingGeometry(0.35, 0.4, 32)
        const targetMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
        })
        const targetMarker = new THREE.Mesh(targetGeometry, targetMaterial)
        targetMarker.rotation.x = -Math.PI / 2
        targetMarker.position.set(
            Math.cos(teethPositions[7].angle) * teethPositions[7].radius,
            0.61,
            Math.sin(teethPositions[7].angle) * teethPositions[7].radius
        )
        scene.add(targetMarker)
        
        // Drill/Implant model
        const drillGroup = new THREE.Group()
        
        // Drill body
        const drillBodyGeometry = new THREE.CylinderGeometry(0.15, 0.1, 3, 16)
        const drillBodyMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xE0E0E0,
            metalness: 0.9,
            roughness: 0.1,
            clearcoat: 1,
            clearcoatRoughness: 0.05,
        })
        const drillBody = new THREE.Mesh(drillBodyGeometry, drillBodyMaterial)
        drillGroup.add(drillBody)
        
        // Drill tip
        const drillTipGeometry = new THREE.ConeGeometry(0.1, 0.5, 8)
        const drillTip = new THREE.Mesh(drillTipGeometry, drillBodyMaterial)
        drillTip.position.y = -1.75
        drillGroup.add(drillTip)
        
        drillGroup.position.y = 3
        scene.add(drillGroup)
        
        // Game state
        let currentMethod = 'freehand'
        let isPlacing = false
        let startTime = 0
        let targetPosition = targetMarker.position.clone()
        let mouseX = 0, mouseY = 0
        
        const methodData = {
            freehand: {
                variance: 0.03,
                shake: 0.02,
                drift: 0.01,
                color: '#ff4444'
            },
            static: {
                variance: 0.015,
                shake: 0.008,
                drift: 0.005,
                color: '#ffaa00'
            },
            yomi: {
                variance: 0.003,
                shake: 0.001,
                drift: 0,
                color: '#00ff88'
            }
        }
        
        // Method selection
        window.setMethod = (method) => {
            currentMethod = method
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.classList.remove('active')
            })
            event.target.classList.add('active')
            
            // Update cursor class
            const cursor = document.getElementById('cursor')
            cursor.className = 'precision-cursor ' + method
            
            // Update instruction
            const methodNames = {
                freehand: 'Freehand - High variance',
                static: 'Static Guided - Medium variance',
                yomi: 'Yomi Robotic - Minimal variance'
            }
            document.getElementById('instructionText').textContent = 
                `${methodNames[method]} - Click to begin placement`
        }
        
        // Mouse tracking
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1
            
            // Update cursor position
            const cursor = document.getElementById('cursor')
            cursor.style.left = event.clientX + 'px'
            cursor.style.top = event.clientY + 'px'
            
            if (isPlacing) {
                updateDrillPosition()
            }
        })
        
        function updateDrillPosition() {
            const raycaster = new THREE.Raycaster()
            raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera)
            
            // Create plane at jaw level
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0)
            const intersectPoint = new THREE.Vector3()
            raycaster.ray.intersectPlane(plane, intersectPoint)
            
            if (intersectPoint) {
                const method = methodData[currentMethod]
                
                // Add variance based on method
                const shakeX = (Math.random() - 0.5) * method.shake
                const shakeZ = (Math.random() - 0.5) * method.shake
                const drift = Math.sin(Date.now() * 0.001) * method.drift
                
                drillGroup.position.x = intersectPoint.x + shakeX + drift
                drillGroup.position.z = intersectPoint.z + shakeZ
                
                // Update metrics
                updateMetrics()
            }
        }
        
        function updateMetrics() {
            const distance = drillGroup.position.distanceTo(targetPosition)
            const angleDeviation = Math.abs(Math.atan2(
                drillGroup.position.x - targetPosition.x,
                drillGroup.position.z - targetPosition.z
            ) * 180 / Math.PI)
            
            const platformDeviation = distance * 10 // Convert to mm
            const depthAccuracy = Math.max(0, 100 - Math.abs(drillGroup.position.y - 2) * 50)
            
            // Update UI
            document.getElementById('angleDeviation').textContent = angleDeviation.toFixed(2) + '°'
            document.getElementById('platformDeviation').textContent = platformDeviation.toFixed(2) + 'mm'
            document.getElementById('depthAccuracy').textContent = depthAccuracy.toFixed(0) + '%'
            
            // Color code values
            const angleEl = document.getElementById('angleDeviation')
            const platformEl = document.getElementById('platformDeviation')
            const depthEl = document.getElementById('depthAccuracy')
            
            angleEl.className = 'metric-value ' + (angleDeviation < 2 ? 'good' : angleDeviation < 5 ? 'warning' : 'bad')
            platformEl.className = 'metric-value ' + (platformDeviation < 0.5 ? 'good' : platformDeviation < 1 ? 'warning' : 'bad')
            depthEl.className = 'metric-value ' + (depthAccuracy > 90 ? 'good' : depthAccuracy > 70 ? 'warning' : 'bad')
        }
        
        // Start placement
        document.addEventListener('click', () => {
            if (!isPlacing) {
                startPlacement()
            } else {
                endPlacement()
            }
        })
        
        function startPlacement() {
            isPlacing = true
            startTime = Date.now()
            document.getElementById('instructionText').textContent = 'Position the drill and click to place'
            
            // Start timer
            const interval = setInterval(() => {
                if (isPlacing) {
                    const elapsed = (Date.now() - startTime) / 1000
                    document.getElementById('timeElapsed').textContent = elapsed.toFixed(1) + 's'
                } else {
                    clearInterval(interval)
                }
            }, 100)
        }
        
        function endPlacement() {
            isPlacing = false
            const finalTime = ((Date.now() - startTime) / 1000).toFixed(1)
            
            // Calculate score
            const angleDeviation = parseFloat(document.getElementById('angleDeviation').textContent)
            const platformDeviation = parseFloat(document.getElementById('platformDeviation').textContent)
            const depthAccuracy = parseFloat(document.getElementById('depthAccuracy').textContent)
            
            const score = Math.round((100 - angleDeviation * 5) * 0.4 + 
                                   (100 - platformDeviation * 20) * 0.4 + 
                                   depthAccuracy * 0.2)
            
            // Show score popup
            showScorePopup(score)
            
            // Show results after delay
            setTimeout(() => {
                showResults(score, finalTime, angleDeviation, platformDeviation)
            }, 1500)
        }
        
        function showScorePopup(score) {
            const popup = document.createElement('div')
            popup.className = 'score-popup'
            popup.textContent = score + '%'
            popup.style.color = score > 90 ? '#00ff88' : score > 70 ? '#ffaa00' : '#ff4444'
            popup.style.left = '50%'
            popup.style.top = '50%'
            document.body.appendChild(popup)
            
            setTimeout(() => popup.remove(), 2000)
        }
        
        function showResults(score, time, angle, platform) {
            document.getElementById('scoreDisplay').textContent = score + '%'
            document.getElementById('scoreDisplay').style.color = 
                score > 90 ? '#00ff88' : score > 70 ? '#ffaa00' : '#ff4444'
            
            document.getElementById('methodResult').textContent = 
                currentMethod.charAt(0).toUpperCase() + currentMethod.slice(1)
            document.getElementById('precisionResult').textContent = platform.toFixed(2) + 'mm'
            document.getElementById('timeResult').textContent = time + 's'
            
            document.getElementById('resultsModal').style.display = 'flex'
        }
        
        window.tryAgain = () => {
            document.getElementById('resultsModal').style.display = 'none'
            drillGroup.position.set(0, 3, 0)
            document.getElementById('instructionText').textContent = 'Select a method and click to begin placement'
        }
        
        window.saveResults = async () => {
            try {
                const { data: { user } } = await supabase.auth.getUser()
                if (user) {
                    const score = parseInt(document.getElementById('scoreDisplay').textContent)
                    const method = document.getElementById('methodResult').textContent
                    const precision = document.getElementById('precisionResult').textContent
                    const time = document.getElementById('timeResult').textContent
                    
                    // Save to Supabase (you'll need to create a 'scores' table)
                    const { error } = await supabase
                        .from('scores')
                        .insert({
                            user_id: user.id,
                            score: score,
                            method: method,
                            precision: precision,
                            time: time,
                            created_at: new Date().toISOString()
                        })
                    
                    if (error) {
                        console.error('Error saving results:', error)
                        alert('Results saved locally')
                    } else {
                        alert('Results saved successfully!')
                    }
                }
            } catch (error) {
                console.error('Save error:', error)
            }
            tryAgain()
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate)
            
            controls.update()
            
            // Animate target marker
            targetMarker.material.opacity = 0.3 + Math.sin(Date.now() * 0.003) * 0.2
            
            // Rotate drill when placing
            if (isPlacing) {
                drillGroup.rotation.y += 0.05
            }
            
            renderer.render(scene, camera)
        }
        animate()
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
        })
        
        // Hide cursor
        document.body.style.cursor = 'none'
        
        } // End of initializeSimulation
    </script>
</body>
</html>