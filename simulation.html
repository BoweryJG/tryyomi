<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TryYomi - Precision Surgery Simulation</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>🦷</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 100;
        }

        .hud > * {
            pointer-events: auto;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 20px;
            padding: 20px;
            min-width: 200px;
        }

        .method-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .method-title {
            font-size: 14px;
            color: #888;
            margin-bottom: 5px;
        }

        .method-btn {
            padding: 12px 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .method-btn.active {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            color: #00ff88;
        }

        .method-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        /* Mode toggle */
        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            flex: 1;
            padding: 10px 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 14px;
        }

        .mode-btn.active {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            color: #00ff88;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Metrics */
        .metrics {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metric-label {
            font-size: 14px;
            color: #888;
        }

        .metric-value {
            font-size: 20px;
            font-weight: 600;
        }

        .metric-value.good {
            color: #00ff88;
        }

        .metric-value.warning {
            color: #ffaa00;
        }

        .metric-value.bad {
            color: #ff4444;
        }

        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 15px;
            padding: 20px 40px;
            text-align: center;
            z-index: 100;
        }

        .instruction-text {
            font-size: 16px;
            color: #00ff88;
            margin-bottom: 10px;
        }

        .controls {
            font-size: 14px;
            color: #888;
        }

        /* Target indicator */
        .target-indicator {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
            display: none; /* Hide screen target, we'll use 3D target */
        }

        .target-ring {
            position: absolute;
            border: 2px solid #00ff88;
            border-radius: 50%;
            opacity: 0.5;
            animation: pulse 2s ease-in-out infinite;
        }

        .ring-1 {
            width: 100px;
            height: 100px;
            left: -50px;
            top: -50px;
        }

        .ring-2 {
            width: 60px;
            height: 60px;
            left: -30px;
            top: -30px;
            animation-delay: 0.5s;
        }

        .ring-3 {
            width: 20px;
            height: 20px;
            left: -10px;
            top: -10px;
            animation-delay: 1s;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 0.5;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
        }

        /* Timer */
        .timer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: 700;
            color: #00ff88;
            opacity: 0;
            pointer-events: none;
            z-index: 200;
            text-shadow: 0 0 50px rgba(0, 255, 136, 0.5);
        }

        .timer.show {
            animation: timerPulse 1s ease-out;
        }

        @keyframes timerPulse {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.2);
            }
        }

        /* Tutorial overlay */
        .tutorial-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }

        .tutorial-overlay.hidden {
            display: none;
        }

        .tutorial-content {
            background: linear-gradient(135deg, #0a0f1b 0%, #1a1f2e 100%);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 30px;
            padding: 50px;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .tutorial-title {
            font-size: 32px;
            font-weight: 700;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
        }

        .tutorial-desc {
            font-size: 18px;
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 40px;
        }

        .tutorial-steps {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 40px;
        }

        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            opacity: 0.5;
            transition: all 0.3s ease;
        }

        .step.active {
            opacity: 1;
        }

        .step-number {
            width: 50px;
            height: 50px;
            border: 2px solid #444;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: 700;
            background: rgba(255, 255, 255, 0.05);
        }

        .step.active .step-number {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
        }

        .step-label {
            font-size: 14px;
            color: #888;
        }

        .step.active .step-label {
            color: #00ff88;
        }

        /* Results modal */
        .results-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .results-content {
            background: linear-gradient(135deg, #0a0f1b 0%, #1a1f2e 100%);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 30px;
            padding: 50px;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .results-title {
            font-size: 36px;
            font-weight: 700;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
        }

        .score-display {
            font-size: 72px;
            font-weight: 800;
            margin-bottom: 20px;
        }

        .score-breakdown {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .breakdown-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
        }

        .breakdown-label {
            font-size: 14px;
            color: #888;
            margin-bottom: 5px;
        }

        .breakdown-value {
            font-size: 24px;
            font-weight: 600;
        }

        .action-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: black;
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid #00ff88;
            color: #00ff88;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        /* Precision cursor */
        .precision-cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 2px solid #00ff88;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
        }

        .precision-cursor.freehand {
            animation: shake 0.15s infinite;
            border-color: #ff4444;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
        }

        .precision-cursor.static {
            animation: shake 0.3s infinite;
            border-color: #ffaa00;
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.6);
        }

        .precision-cursor.yomi {
            animation: none;
            border-color: #00ff88;
            box-shadow: 0 0 30px rgba(0, 255, 136, 1);
            border-width: 3px;
        }

        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            10% { transform: translate(-45%, -55%) rotate(2deg); }
            20% { transform: translate(-55%, -45%) rotate(-2deg); }
            30% { transform: translate(-52%, -53%) rotate(1deg); }
            40% { transform: translate(-48%, -47%) rotate(-1deg); }
            50% { transform: translate(-53%, -50%) rotate(3deg); }
            60% { transform: translate(-47%, -52%) rotate(-3deg); }
            70% { transform: translate(-51%, -48%) rotate(2deg); }
            80% { transform: translate(-49%, -54%) rotate(-1deg); }
            90% { transform: translate(-54%, -46%) rotate(1deg); }
        }

        /* Score animation */
        .score-popup {
            position: fixed;
            font-size: 48px;
            font-weight: 700;
            pointer-events: none;
            z-index: 200;
            animation: scoreFloat 2s ease-out forwards;
        }

        @keyframes scoreFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) scale(1.5);
            }
        }
    </style>
    <!-- Configuration -->
    <script src="config.js"></script>
    <!-- Google Analytics -->
    <script async id="ga-script"></script>
    <script>
        // Load GA script with configured ID
        document.getElementById('ga-script').src = `https://www.googletagmanager.com/gtag/js?id=${CONFIG.GA_MEASUREMENT_ID}`;
        
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', CONFIG.GA_MEASUREMENT_ID);
    </script>
</head>
<body>
    <!-- Auth check overlay with benefits showcase -->
    <div id="authCheck" style="position: fixed; inset: 0; background: #000; z-index: 9999; overflow: hidden;">
        <!-- Background particles -->
        <div class="particles-bg"></div>
        
        <!-- Benefits carousel -->
        <div class="benefits-showcase">
            <div class="benefit-card active" id="benefit1">
                <div class="benefit-icon">
                    <svg width="80" height="80" viewBox="0 0 100 100">
                        <circle cx="50" cy="50" r="45" fill="none" stroke="#00ff88" stroke-width="2" opacity="0.3"/>
                        <circle cx="50" cy="50" r="30" fill="none" stroke="#00ff88" stroke-width="3" opacity="0.5"/>
                        <circle cx="50" cy="50" r="15" fill="none" stroke="#00ff88" stroke-width="4"/>
                        <circle cx="50" cy="50" r="5" fill="#00ff88"/>
                    </svg>
                </div>
                <h2 class="benefit-title">Sub-Millimeter Precision</h2>
                <div class="benefit-stat">&lt;0.2mm</div>
                <p class="benefit-desc">Average deviation with Yomi vs 2.5mm freehand</p>
                <div class="benefit-visual">
                    <div class="comparison-bar">
                        <div class="bar freehand" style="width: 100%;">
                            <span>Freehand: 2.5mm</span>
                        </div>
                        <div class="bar yomi" style="width: 8%;">
                            <span>Yomi: 0.2mm</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="benefit-card" id="benefit2">
                <div class="benefit-icon">
                    <svg width="80" height="80" viewBox="0 0 100 100">
                        <path d="M50 10 C30 10 10 30 10 50 C10 70 30 90 50 90 C70 90 90 70 90 50 C90 30 70 10 50 10" 
                              fill="none" stroke="#00ff88" stroke-width="3"/>
                        <path d="M35 50 L45 60 L65 35" fill="none" stroke="#00ff88" stroke-width="4" stroke-linecap="round"/>
                    </svg>
                </div>
                <h2 class="benefit-title">Higher Success Rates</h2>
                <div class="benefit-stat">99.2%</div>
                <p class="benefit-desc">Implant success rate over 5 years</p>
                <div class="benefit-visual">
                    <div class="success-ring">
                        <svg width="120" height="120">
                            <circle cx="60" cy="60" r="50" fill="none" stroke="#333" stroke-width="10"/>
                            <circle cx="60" cy="60" r="50" fill="none" stroke="#00ff88" stroke-width="10"
                                    stroke-dasharray="314" stroke-dashoffset="3" transform="rotate(-90 60 60)"/>
                        </svg>
                        <div class="ring-text">99.2%</div>
                    </div>
                </div>
            </div>
            
            <div class="benefit-card" id="benefit3">
                <div class="benefit-icon">
                    <svg width="80" height="80" viewBox="0 0 100 100">
                        <circle cx="30" cy="30" r="20" fill="#00ff88" opacity="0.3"/>
                        <circle cx="70" cy="30" r="20" fill="#00ff88" opacity="0.3"/>
                        <path d="M20 60 Q50 80 80 60" fill="none" stroke="#00ff88" stroke-width="3"/>
                    </svg>
                </div>
                <h2 class="benefit-title">Patient Satisfaction</h2>
                <div class="benefit-stat">50%</div>
                <p class="benefit-desc">Less post-operative discomfort</p>
                <div class="benefit-visual">
                    <div class="patient-benefits">
                        <div class="patient-item">
                            <span class="check">✓</span> Faster healing
                        </div>
                        <div class="patient-item">
                            <span class="check">✓</span> Less invasive
                        </div>
                        <div class="patient-item">
                            <span class="check">✓</span> Predictable results
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="benefit-card" id="benefit4">
                <div class="benefit-icon">
                    <svg width="80" height="80" viewBox="0 0 100 100">
                        <rect x="20" y="30" width="60" height="40" fill="none" stroke="#00ff88" stroke-width="3" rx="5"/>
                        <circle cx="35" cy="50" r="5" fill="#00ff88"/>
                        <circle cx="50" cy="50" r="5" fill="#00ff88"/>
                        <circle cx="65" cy="50" r="5" fill="#00ff88"/>
                        <path d="M30 20 L50 10 L70 20" fill="none" stroke="#00ff88" stroke-width="3"/>
                    </svg>
                </div>
                <h2 class="benefit-title">Revolutionary Technology</h2>
                <div class="benefit-stat">FDA</div>
                <p class="benefit-desc">Cleared robotic guidance system</p>
                <div class="benefit-visual">
                    <div class="tech-features">
                        <div class="tech-item">Haptic feedback</div>
                        <div class="tech-item">Real-time tracking</div>
                        <div class="tech-item">3D visualization</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Progress indicator -->
        <div class="showcase-progress">
            <div class="progress-dot active" data-benefit="1"></div>
            <div class="progress-dot" data-benefit="2"></div>
            <div class="progress-dot" data-benefit="3"></div>
            <div class="progress-dot" data-benefit="4"></div>
        </div>
        
        <!-- Loading indicator -->
        <div class="loading-footer">
            <div class="loading-spinner"></div>
            <span>Preparing your precision surgery experience...</span>
        </div>
    </div>
    
    <style>
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .particles-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        .particles-bg::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, #00ff88 1px, transparent 1px);
            background-size: 50px 50px;
            animation: drift 20s linear infinite;
            opacity: 0.03;
        }
        
        @keyframes drift {
            from { transform: translate(-50%, -50%); }
            to { transform: translate(0, 0); }
        }
        
        .benefits-showcase {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            height: 500px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .benefit-card {
            position: absolute;
            width: 100%;
            background: linear-gradient(135deg, rgba(10, 15, 27, 0.9) 0%, rgba(26, 31, 46, 0.9) 100%);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 30px;
            padding: 50px;
            text-align: center;
            opacity: 0;
            transform: translateX(100px) scale(0.9);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .benefit-card.active {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
        
        .benefit-card.prev {
            transform: translateX(-100px) scale(0.9);
            opacity: 0;
        }
        
        .benefit-icon {
            margin-bottom: 30px;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .benefit-title {
            font-size: 28px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .benefit-stat {
            font-size: 72px;
            font-weight: 800;
            color: #00ff88;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .benefit-desc {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 30px;
        }
        
        .benefit-visual {
            margin-top: 30px;
        }
        
        .comparison-bar {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            overflow: hidden;
            height: 60px;
        }
        
        .bar {
            position: absolute;
            height: 30px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            padding: 0 15px;
            color: #fff;
            font-size: 14px;
            transition: width 1s ease-out;
        }
        
        .bar.freehand {
            background: linear-gradient(90deg, #ff4444 0%, #cc0000 100%);
            top: 0;
        }
        
        .bar.yomi {
            background: linear-gradient(90deg, #00ff88 0%, #00cc66 100%);
            bottom: 0;
        }
        
        .success-ring {
            position: relative;
            display: inline-block;
        }
        
        .ring-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: 700;
            color: #00ff88;
        }
        
        .patient-benefits {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .patient-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            color: #fff;
            opacity: 0;
            animation: slideIn 0.5s ease-out forwards;
        }
        
        .patient-item:nth-child(1) { animation-delay: 0.2s; }
        .patient-item:nth-child(2) { animation-delay: 0.4s; }
        .patient-item:nth-child(3) { animation-delay: 0.6s; }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .check {
            color: #00ff88;
            font-size: 24px;
        }
        
        .tech-features {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tech-item {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            color: #00ff88;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.8); }
        }
        
        .showcase-progress {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }
        
        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .progress-dot.active {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }
        
        .loading-footer {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            color: #888;
            font-size: 14px;
        }
        
        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-top-color: #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
    </style>
    
    <canvas id="canvas"></canvas>
    
    <!-- Custom cursor -->
    <div class="precision-cursor" id="cursor"></div>
    
    <!-- HUD -->
    <div class="hud">
        <div class="hud-panel">
            <div class="mode-toggle" style="margin-bottom: 20px;">
                <button class="mode-btn active" onclick="setMode('explore')">🔍 Explore</button>
                <button class="mode-btn" onclick="setMode('challenge')">🎯 Challenge</button>
            </div>
            <div class="method-selector">
                <div class="method-title">SURGICAL METHOD</div>
                <button class="method-btn active" onclick="setMethod('freehand')">Freehand</button>
                <button class="method-btn" onclick="setMethod('static')">Static Guided</button>
                <button class="method-btn" onclick="setMethod('yomi')">Yomi Robotic</button>
            </div>
        </div>
        
        <div class="hud-panel">
            <div class="metrics">
                <div class="metric">
                    <span class="metric-label">Distance from Target</span>
                    <span class="metric-value" id="platformDeviation">0.00mm</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Precision Goal</span>
                    <span class="metric-value good">&lt;1mm</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Time Elapsed</span>
                    <span class="metric-value" id="timeElapsed">0.0s</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Target indicator -->
    <div class="target-indicator" id="targetIndicator">
        <div class="target-ring ring-1"></div>
        <div class="target-ring ring-2"></div>
        <div class="target-ring ring-3"></div>
    </div>
    
    <!-- Instructions -->
    <div class="instructions">
        <div class="instruction-text" id="instructionText">Welcome! Let's explore how surgical precision improves with technology</div>
        <div class="controls" id="controlsText">We'll start with freehand surgery to see the challenges</div>
    </div>
    
    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-content">
            <h2 class="tutorial-title" id="tutorialTitle">Welcome to Precision Surgery Training</h2>
            <p class="tutorial-desc" id="tutorialDesc">
                You'll experience three different surgical methods, from most challenging to easiest.
                Watch how technology dramatically improves precision and reduces surgeon fatigue.
            </p>
            <div class="tutorial-steps">
                <div class="step active" id="step1">
                    <div class="step-number">1</div>
                    <div class="step-label">Freehand</div>
                </div>
                <div class="step" id="step2">
                    <div class="step-number">2</div>
                    <div class="step-label">Static Guide</div>
                </div>
                <div class="step" id="step3">
                    <div class="step-number">3</div>
                    <div class="step-label">Yomi Robot</div>
                </div>
            </div>
            <button class="btn btn-primary" onclick="startTutorial()">Start Tutorial</button>
        </div>
    </div>
    
    <!-- Timer -->
    <div class="timer" id="timer">3</div>
    
    <!-- Results Modal -->
    <div class="results-modal" id="resultsModal">
        <div class="results-content">
            <h2 class="results-title">Procedure Complete!</h2>
            <div class="score-display" id="scoreDisplay">95%</div>
            
            <div class="score-breakdown">
                <div class="breakdown-item">
                    <div class="breakdown-label">Method</div>
                    <div class="breakdown-value" id="methodResult">Freehand</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-label">Precision</div>
                    <div class="breakdown-value" id="precisionResult">0.5mm</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-label">Time</div>
                    <div class="breakdown-value" id="timeResult">12.3s</div>
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="btn btn-primary" onclick="tryAgain()">Try Again</button>
                <button class="btn btn-secondary" onclick="saveResults()">Save Results</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three'
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js'
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm'
        
        // Supabase configuration from config.js
        const supabase = createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY)
        
        // Check authentication
        async function checkAuth() {
            console.log('Checking authentication...')
            
            // Add timeout for auth check
            const timeoutPromise = new Promise((resolve, reject) => {
                setTimeout(() => reject(new Error('Auth check timeout')), 5000)
            })
            
            const authPromise = (async () => {
                const { data: { user }, error } = await supabase.auth.getUser()
                
                if (error) {
                    console.error('Auth error:', error)
                    throw error
                }
                
                if (!user) {
                    // Not authenticated, redirect to home
                    console.log('No user found, redirecting...')
                    alert('Please sign in to use the simulator')
                    window.location.href = 'index.html'
                    return false
                }
                
                console.log('User authenticated:', user.email)
                // Hide auth check overlay
                document.getElementById('authCheck').style.display = 'none'
                return true
            })()
            
            try {
                return await Promise.race([authPromise, timeoutPromise])
            } catch (error) {
                console.error('Auth check failed:', error)
                alert('Authentication check failed. Redirecting to home page.')
                window.location.href = 'index.html'
                return false
            }
        }
        
        // Benefits carousel - initialize after DOM is ready
        window.addEventListener('DOMContentLoaded', () => {
            let currentBenefit = 1
            const totalBenefits = 4
            let benefitInterval = null
            
            function showBenefit(num) {
                // Update cards
                const cards = document.querySelectorAll('.benefit-card')
                if (!cards.length) return // Exit if cards not found
                
                cards.forEach(card => {
                    card.classList.remove('active', 'prev')
                })
                
                const currentCard = document.getElementById(`benefit${num}`)
                if (currentCard) {
                    currentCard.classList.add('active')
                }
                
                // Update previous card
                const prevNum = num === 1 ? totalBenefits : num - 1
                const prevCard = document.getElementById(`benefit${prevNum}`)
                if (prevCard) {
                    prevCard.classList.add('prev')
                }
                
                // Update progress dots
                document.querySelectorAll('.progress-dot').forEach((dot, index) => {
                    dot.classList.toggle('active', index + 1 === num)
                })
            }
            
            function nextBenefit() {
                currentBenefit = currentBenefit >= totalBenefits ? 1 : currentBenefit + 1
                showBenefit(currentBenefit)
            }
            
            // Initialize first card
            showBenefit(1)
            
            // Start carousel animation after a delay
            setTimeout(() => {
                benefitInterval = setInterval(nextBenefit, 6000) // 6 seconds per card
            }, 3000) // 3 second delay to read first card
            
            // Add click handlers to progress dots
            document.querySelectorAll('.progress-dot').forEach((dot, index) => {
                dot.addEventListener('click', () => {
                    if (benefitInterval) clearInterval(benefitInterval)
                    currentBenefit = index + 1
                    showBenefit(currentBenefit)
                    // Restart with longer interval after manual click
                    setTimeout(() => {
                        benefitInterval = setInterval(nextBenefit, 6000)
                    }, 2000)
                })
            })
            
            // Store interval reference globally for cleanup
            window.benefitInterval = benefitInterval
        })
        
        // Wait for config to load then check auth
        setTimeout(() => {
            if (typeof CONFIG === 'undefined') {
                console.error('CONFIG not loaded! Check config.js')
                alert('Configuration failed to load. Please refresh the page.')
                document.getElementById('authCheck').innerHTML = '<div style="text-align: center; color: #ff4444;"><h2>Configuration Error</h2><p>Please refresh the page</p></div>'
            } else {
                console.log('Config loaded, checking auth...')
                // Only initialize the game if authenticated
                checkAuth().then(isAuthenticated => {
                    console.log('Auth check complete:', isAuthenticated)
                    if (isAuthenticated) {
                        // Stop carousel when auth succeeds
                        if (window.benefitInterval) clearInterval(window.benefitInterval)
                        initializeSimulation()
                    }
                }).catch(err => {
                    console.error('Auth check promise failed:', err)
                    if (window.benefitInterval) clearInterval(window.benefitInterval)
                    document.getElementById('authCheck').innerHTML = '<div style="text-align: center; color: #ff4444;"><h2>Authentication Error</h2><p>' + err.message + '</p><button onclick="window.location.href=\'index.html\'" style="margin-top: 20px; padding: 10px 20px; background: #00ff88; color: black; border: none; border-radius: 5px; cursor: pointer;">Go to Home</button></div>'
                })
            }
        }, 500) // Increased delay to ensure config.js loads
        
        function initializeSimulation() {
        
        // Scene setup
        const scene = new THREE.Scene()
        scene.fog = new THREE.Fog(0x000000, 10, 50)
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.set(0, 5, 8)
        
        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('canvas'),
            antialias: true,
            alpha: false
        })
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFSoftShadowMap
        renderer.toneMapping = THREE.ACESFilmicToneMapping
        renderer.toneMappingExposure = 1.2
        
        // Controls
        const controls = new OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.dampingFactor = 0.05
        controls.maxPolarAngle = Math.PI / 2.2
        controls.minDistance = 5
        controls.maxDistance = 15
        controls.target.set(0, 0, 0)
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5)
        scene.add(ambientLight)
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 1)
        mainLight.position.set(5, 10, 5)
        mainLight.castShadow = true
        mainLight.shadow.camera.near = 0.1
        mainLight.shadow.camera.far = 50
        mainLight.shadow.camera.left = -10
        mainLight.shadow.camera.right = 10
        mainLight.shadow.camera.top = 10
        mainLight.shadow.camera.bottom = -10
        mainLight.shadow.mapSize.width = 2048
        mainLight.shadow.mapSize.height = 2048
        scene.add(mainLight)
        
        const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3)
        fillLight.position.set(-5, 5, -5)
        scene.add(fillLight)
        
        // Create realistic jaw
        const jawGroup = new THREE.Group()
        
        // Jaw bone
        const jawGeometry = new THREE.TorusGeometry(3.5, 1.5, 24, 48, Math.PI)
        const jawMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xFFE4E1,
            roughness: 0.8,
            metalness: 0,
            clearcoat: 0.2,
            clearcoatRoughness: 0.9,
            bumpScale: 0.002,
        })
        
        const jaw = new THREE.Mesh(jawGeometry, jawMaterial)
        jaw.rotation.x = -Math.PI / 2
        jaw.castShadow = true
        jaw.receiveShadow = true
        jawGroup.add(jaw)
        
        // Gum tissue
        const gumGeometry = new THREE.TorusGeometry(3.3, 1.4, 24, 48, Math.PI)
        const gumMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xFFB5C5,
            roughness: 0.9,
            metalness: 0,
            clearcoat: 0.1,
            transmission: 0.1,
            thickness: 0.5,
        })
        
        const gum = new THREE.Mesh(gumGeometry, gumMaterial)
        gum.rotation.x = -Math.PI / 2
        gum.position.y = 0.1
        gum.castShadow = true
        gum.receiveShadow = true
        jawGroup.add(gum)
        
        // Create realistic teeth
        const teethGroup = new THREE.Group()
        
        function createTooth(type = 'molar') {
            let geometry
            
            // Create smooth, realistic tooth shapes using SphereGeometry as base
            if (type === 'molar') {
                // Start with a sphere and deform it
                geometry = new THREE.SphereGeometry(0.4, 32, 32)
                
                // Flatten and shape into molar
                const positions = geometry.attributes.position
                for (let i = 0; i < positions.count; i++) {
                    let x = positions.getX(i)
                    let y = positions.getY(i)
                    let z = positions.getZ(i)
                    
                    // Flatten the sphere vertically
                    y *= 0.5
                    
                    // Create crown with smooth cusps
                    if (y > 0) {
                        const angle = Math.atan2(z, x)
                        const cuspPattern = 0.8 + 0.2 * Math.sin(angle * 4)
                        y *= cuspPattern
                        
                        // Smooth the top surface
                        const topFactor = 1 - (y / 0.4)
                        x *= (0.9 + topFactor * 0.1)
                        z *= (0.9 + topFactor * 0.1)
                    }
                    
                    // Taper towards the root
                    if (y < -0.1) {
                        const rootFactor = (y + 0.1) / -0.3
                        x *= (1 - rootFactor * 0.3)
                        z *= (1 - rootFactor * 0.3)
                    }
                    
                    positions.setXYZ(i, x, y + 0.4, z)
                }
            } else if (type === 'premolar') {
                // Smaller sphere base
                geometry = new THREE.SphereGeometry(0.3, 24, 24)
                
                const positions = geometry.attributes.position
                for (let i = 0; i < positions.count; i++) {
                    let x = positions.getX(i)
                    let y = positions.getY(i)
                    let z = positions.getZ(i)
                    
                    // Elongate vertically
                    y *= 0.7
                    
                    // Two smooth cusps
                    if (y > 0) {
                        const cuspPattern = 0.9 + 0.1 * Math.abs(x)
                        y *= cuspPattern
                    }
                    
                    // Taper root
                    if (y < 0) {
                        const rootFactor = -y / 0.3
                        x *= (1 - rootFactor * 0.2)
                        z *= (1 - rootFactor * 0.2)
                    }
                    
                    positions.setXYZ(i, x, y + 0.45, z)
                }
            } else if (type === 'canine') {
                // Teardrop shape
                geometry = new THREE.SphereGeometry(0.25, 24, 24)
                
                const positions = geometry.attributes.position
                for (let i = 0; i < positions.count; i++) {
                    let x = positions.getX(i)
                    let y = positions.getY(i)
                    let z = positions.getZ(i)
                    
                    // Create pointed crown
                    if (y > 0) {
                        const pointFactor = y / 0.25
                        x *= (1 - pointFactor * 0.7)
                        z *= (1 - pointFactor * 0.7)
                        y *= 2 // Elongate upward
                    }
                    
                    // Smooth taper to root
                    if (y < 0) {
                        y *= 1.5
                        const rootFactor = -y / 0.375
                        x *= (1 - rootFactor * 0.3)
                        z *= (1 - rootFactor * 0.3)
                    }
                    
                    positions.setXYZ(i, x, y + 0.5, z)
                }
            } else {
                // Incisors - flattened sphere
                geometry = new THREE.SphereGeometry(0.2, 24, 24)
                
                const positions = geometry.attributes.position
                for (let i = 0; i < positions.count; i++) {
                    let x = positions.getX(i)
                    let y = positions.getY(i)
                    let z = positions.getZ(i)
                    
                    // Flatten front-to-back
                    z *= 0.3
                    
                    // Elongate vertically
                    y *= 1.5
                    
                    // Chisel edge
                    if (y > 0.2) {
                        const edgeFactor = (y - 0.2) / 0.1
                        z *= (1 - edgeFactor * 0.5)
                    }
                    
                    // Root taper
                    if (y < 0) {
                        const rootFactor = -y / 0.3
                        x *= (1 - rootFactor * 0.2)
                        z *= (1 - rootFactor * 0.2)
                    }
                    
                    positions.setXYZ(i, x, y + 0.5, z)
                }
            }
            
            // Add organic variation to all teeth
            const positions = geometry.attributes.position
            for (let i = 0; i < positions.count; i++) {
                const y = positions.getY(i)
                const x = positions.getX(i)
                const z = positions.getZ(i)
                
                // Smooth the crown with sine wave modulation
                if (y > 0.3) {
                    const crownShape = Math.sin(y * Math.PI) * 0.1
                    positions.setX(i, x * (1 + crownShape))
                    positions.setZ(i, z * (1 + crownShape))
                }
                
                // Add subtle surface variation
                const variation = (Math.sin(x * 10) * Math.cos(z * 10)) * 0.02
                positions.setY(i, y + variation)
            }
            
            geometry.computeVertexNormals()
            
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xFFFFF0,
                roughness: 0.2,
                metalness: 0,
                clearcoat: 1,
                clearcoatRoughness: 0.05,
                reflectivity: 0.5,
                envMapIntensity: 1,
                sheen: 0.5,
                sheenRoughness: 0.2,
                sheenColor: 0xffffff,
            })
            
            const tooth = new THREE.Mesh(geometry, material)
            tooth.castShadow = true
            tooth.receiveShadow = true
            
            return tooth
        }
        
        // Place teeth in realistic dental arch
        const teethPositions = []
        
        // Lower jaw dental arch - 16 teeth total (8 per side)
        // Using parabolic curve for realistic arch shape
        function getArchPosition(index, total) {
            const t = (index / (total - 1)) * Math.PI // 0 to PI for half circle
            const archWidth = 3.5
            const archDepth = 3.0
            
            // Parabolic arch formula for more realistic shape
            const x = Math.cos(t) * archWidth * (1 - 0.3 * Math.sin(t))
            const z = Math.sin(t) * archDepth
            
            return { x, z }
        }
        
        // Define teeth layout (left to right)
        const teethLayout = [
            'molar', 'molar', 'premolar', 'premolar', 'canine', 'incisor', 'incisor', 'incisor',
            'incisor', 'incisor', 'incisor', 'canine', 'premolar', 'premolar', 'molar', 'molar'
        ]
        
        teethLayout.forEach((type, index) => {
            const pos = getArchPosition(index, teethLayout.length)
            teethPositions.push({
                x: pos.x,
                z: pos.z,
                type: type,
                index: index
            })
        })
        
        teethPositions.forEach((pos, index) => {
            const tooth = createTooth(pos.type)
            tooth.position.x = pos.x
            tooth.position.z = pos.z
            tooth.position.y = 0.6
            
            // Slight random rotation for realism
            tooth.rotation.y = (Math.random() - 0.5) * 0.1
            tooth.rotation.z = (Math.random() - 0.5) * 0.05
            
            // Skip tooth #10 (lower left lateral incisor) for implant site
            if (index !== 10) {
                teethGroup.add(tooth)
            }
        })
        
        jawGroup.add(teethGroup)
        scene.add(jawGroup)
        
        // Target site marker - MUCH MORE VISIBLE
        const targetGroup = new THREE.Group()
        
        // Main target ring
        const targetGeometry = new THREE.RingGeometry(0.35, 0.45, 32)
        const targetMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        })
        const targetMarker = new THREE.Mesh(targetGeometry, targetMaterial)
        targetMarker.rotation.x = -Math.PI / 2
        targetGroup.add(targetMarker)
        
        // Glowing center point
        const centerGeometry = new THREE.SphereGeometry(0.1, 16, 16)
        const centerMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ff88,
            emissive: 0x00ff88,
            emissiveIntensity: 2
        })
        const centerMarker = new THREE.Mesh(centerGeometry, centerMaterial)
        centerMarker.position.y = 0.05
        targetGroup.add(centerMarker)
        
        // Outer pulse ring
        const pulseGeometry = new THREE.RingGeometry(0.5, 0.6, 32)
        const pulseMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        })
        const pulseRing = new THREE.Mesh(pulseGeometry, pulseMaterial)
        pulseRing.rotation.x = -Math.PI / 2
        targetGroup.add(pulseRing)
        
        // Arrow pointing down
        const arrowGeometry = new THREE.ConeGeometry(0.2, 0.5, 8)
        const arrowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.7
        })
        const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial)
        arrow.position.y = 1.5
        arrow.rotation.x = Math.PI
        targetGroup.add(arrow)
        
        // "TARGET HERE" text sprite
        const canvas = document.createElement('canvas')
        canvas.width = 256
        canvas.height = 64
        const ctx = canvas.getContext('2d')
        ctx.fillStyle = '#00ff88'
        ctx.font = 'bold 32px Arial'
        ctx.textAlign = 'center'
        ctx.fillText('TARGET HERE', 128, 40)
        
        const texture = new THREE.CanvasTexture(canvas)
        const spriteMaterial = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            opacity: 0.9
        })
        const sprite = new THREE.Sprite(spriteMaterial)
        sprite.position.y = 2
        sprite.scale.set(2, 0.5, 1)
        targetGroup.add(sprite)
        
        // Position target at missing tooth location
        const missingToothPos = teethPositions[10] // Lower left lateral incisor
        targetGroup.position.set(
            missingToothPos.x,
            0.61,
            missingToothPos.z
        )
        scene.add(targetGroup)
        
        const targetPosition = targetGroup.position.clone()
        
        // Drill/Implant model
        const drillGroup = new THREE.Group()
        
        // Drill body
        const drillBodyGeometry = new THREE.CylinderGeometry(0.15, 0.1, 3, 16)
        const drillBodyMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xE0E0E0,
            metalness: 0.9,
            roughness: 0.1,
            clearcoat: 1,
            clearcoatRoughness: 0.05,
        })
        const drillBody = new THREE.Mesh(drillBodyGeometry, drillBodyMaterial)
        drillGroup.add(drillBody)
        
        // Drill tip
        const drillTipGeometry = new THREE.ConeGeometry(0.1, 0.5, 8)
        const drillTipMesh = new THREE.Mesh(drillTipGeometry, drillBodyMaterial)
        drillTipMesh.position.y = -1.75
        drillGroup.add(drillTipMesh)
        
        // Add glowing tip indicator
        const tipIndicatorGeometry = new THREE.SphereGeometry(0.05, 8, 8)
        const tipIndicatorMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.8
        })
        const tipIndicator = new THREE.Mesh(tipIndicatorGeometry, tipIndicatorMaterial)
        tipIndicator.position.y = -2 // At the very tip of the drill
        drillGroup.add(tipIndicator)
        
        // Add laser pointer from tip to show where it will land
        const laserGeometry = new THREE.CylinderGeometry(0.01, 0.01, 5, 8)
        const laserMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.3
        })
        const laser = new THREE.Mesh(laserGeometry, laserMaterial)
        laser.position.y = -4.5 // Extends down from drill tip
        drillGroup.add(laser)
        
        drillGroup.position.y = 3
        scene.add(drillGroup)
        
        // Store references to important objects
        const drillTip = tipIndicator
        const drillLaser = laser
        
        // Game state
        let currentMethod = 'freehand'
        let currentMode = 'explore'
        let isPlacing = false
        let startTime = 0
        let mouseX = 0, mouseY = 0
        let tutorialMode = true
        let tutorialStep = 1
        let methodScores = {
            freehand: null,
            static: null,
            yomi: null
        }
        
        const methodData = {
            freehand: {
                variance: 0.08,      // Much higher variance
                shake: 0.05,         // Very shaky
                drift: 0.03,         // Significant drift
                color: '#ff4444',
                description: 'Extremely difficult to achieve precision'
            },
            static: {
                variance: 0.025,     // Moderate variance
                shake: 0.015,        // Some shake
                drift: 0.008,        // Some drift
                color: '#ffaa00',
                description: 'Better than freehand, but still challenging'
            },
            yomi: {
                variance: 0.001,     // Almost no variance
                shake: 0.0002,       // Virtually no shake
                drift: 0,            // No drift at all
                color: '#00ff88',
                description: 'Robotic precision - consistently accurate'
            }
        }
        
        // Mode functions
        window.setMode = (mode, fromButton = true) => {
            currentMode = mode
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active')
            })
            
            // Add active class to the correct button
            if (fromButton && event && event.target) {
                event.target.classList.add('active')
            } else {
                // Find and activate the correct button
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    if (btn.textContent.toLowerCase().includes(mode)) {
                        btn.classList.add('active')
                    }
                })
            }
            
            if (mode === 'explore') {
                // Hide metrics in explore mode
                document.querySelector('.hud-panel:last-child').style.display = 'none'
                targetGroup.visible = false
                document.getElementById('instructionText').textContent = 'Explore Mode - Move the drill freely'
                document.getElementById('controlsText').textContent = 'Experience the different surgical methods without pressure'
            } else {
                // Show metrics in challenge mode
                document.querySelector('.hud-panel:last-child').style.display = 'block'
                targetGroup.visible = true
                document.getElementById('instructionText').textContent = 'Challenge Mode - Hit the target!'
                document.getElementById('controlsText').textContent = 'Test your precision with each method'
            }
        }

        // Tutorial functions
        window.startTutorial = () => {
            document.getElementById('tutorialOverlay').classList.add('hidden')
            tutorialMode = true
            tutorialStep = 1
            setMethodForTutorial('freehand')
            updateTutorialUI()
            // Start in challenge mode for tutorial
            setMode('challenge', false)
        }

        function updateTutorialUI() {
            const tutorials = {
                1: {
                    title: "Step 1: Freehand Surgery",
                    instruction: "Click to start, then move your mouse to the GREEN TARGET and click to place",
                    controls: "Watch how difficult it is to hit the target - your hand naturally shakes!",
                    method: 'freehand'
                },
                2: {
                    title: "Step 2: Static Guided Surgery",
                    instruction: "Click to start, then guide the drill to the GREEN TARGET",
                    controls: "Better than freehand, but still challenging to hit the exact center",
                    method: 'static'
                },
                3: {
                    title: "Step 3: Yomi Robotic Surgery",
                    instruction: "Click to start, then easily guide to the GREEN TARGET",
                    controls: "Notice how the robot stabilizes your movements - precision is effortless!",
                    method: 'yomi'
                }
            }

            const current = tutorials[tutorialStep]
            document.getElementById('instructionText').textContent = current.title
            document.getElementById('controlsText').textContent = current.instruction
            
            // Update step indicators
            document.querySelectorAll('.step').forEach((step, index) => {
                step.classList.toggle('active', index + 1 === tutorialStep)
            })
        }

        function setMethodForTutorial(method) {
            currentMethod = method
            
            // Update button states
            document.querySelectorAll('.method-btn').forEach((btn, index) => {
                btn.classList.remove('active')
                
                // Match button by text content
                const btnText = btn.textContent.toLowerCase()
                if ((method === 'freehand' && btnText.includes('freehand')) ||
                    (method === 'static' && btnText.includes('static')) ||
                    (method === 'yomi' && btnText.includes('yomi'))) {
                    btn.classList.add('active')
                }
            })
            
            // Update cursor
            const cursor = document.getElementById('cursor')
            cursor.className = 'precision-cursor ' + method
        }

        // Method selection
        window.setMethod = (method) => {
            if (tutorialMode) return // Prevent manual switching during tutorial
            
            currentMethod = method
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.classList.remove('active')
            })
            event.target.classList.add('active')
            
            // Track method selection
            gtag('event', 'method_selected', {
                'method': method
            });
            
            // Update cursor class
            const cursor = document.getElementById('cursor')
            cursor.className = 'precision-cursor ' + method
            
            // Update instruction with emphasis on difficulty
            const methodNames = {
                freehand: 'Freehand - VERY DIFFICULT to achieve precision',
                static: 'Static Guided - Moderate difficulty',
                yomi: 'Yomi Robotic - EASY precision with robotic guidance'
            }
            document.getElementById('instructionText').textContent = 
                `${methodNames[method]} - Click to begin placement`
            
            // Update instruction text color based on method
            const instructionEl = document.getElementById('instructionText')
            instructionEl.style.color = methodData[method].color
        }
        
        // Mouse tracking
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1
            
            // Update cursor position
            const cursor = document.getElementById('cursor')
            cursor.style.left = event.clientX + 'px'
            cursor.style.top = event.clientY + 'px'
            
            if (isPlacing) {
                updateDrillPosition()
            }
        })
        
        function updateDrillPosition() {
            const raycaster = new THREE.Raycaster()
            raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera)
            
            // Create plane at jaw level
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0)
            const intersectPoint = new THREE.Vector3()
            raycaster.ray.intersectPlane(plane, intersectPoint)
            
            if (intersectPoint) {
                const method = methodData[currentMethod]
                
                // Add variance based on method
                const shakeX = (Math.random() - 0.5) * method.shake
                const shakeZ = (Math.random() - 0.5) * method.shake
                const shakeY = (Math.random() - 0.5) * method.shake * 0.5
                const drift = Math.sin(Date.now() * 0.001) * method.drift
                const driftY = Math.cos(Date.now() * 0.0015) * method.drift * 0.3
                
                drillGroup.position.x = intersectPoint.x + shakeX + drift
                drillGroup.position.z = intersectPoint.z + shakeZ
                drillGroup.position.y = 3 + shakeY + driftY
                
                // Add rotation shake for freehand
                if (currentMethod === 'freehand') {
                    drillGroup.rotation.x = (Math.random() - 0.5) * 0.1
                    drillGroup.rotation.z = (Math.random() - 0.5) * 0.1
                } else if (currentMethod === 'static') {
                    drillGroup.rotation.x = (Math.random() - 0.5) * 0.02
                    drillGroup.rotation.z = (Math.random() - 0.5) * 0.02
                } else {
                    drillGroup.rotation.x = 0
                    drillGroup.rotation.z = 0
                }
                
                // Update metrics
                updateMetrics()
            }
        }
        
        function updateMetrics() {
            if (currentMode === 'explore') return // No metrics in explore mode
            
            // Calculate drill tip position in world space
            const drillTipWorld = new THREE.Vector3(
                drillGroup.position.x,
                drillGroup.position.y - 2, // Tip is 2 units below drill center
                drillGroup.position.z
            )
            
            // Get 2D distance (ignoring height) from drill tip to target
            const distance2D = Math.sqrt(
                Math.pow(drillTipWorld.x - targetPosition.x, 2) +
                Math.pow(drillTipWorld.z - targetPosition.z, 2)
            )
            
            const platformDeviation = distance2D * 10 // Convert to mm
            
            // Update UI - MAIN METRIC IS DISTANCE FROM TARGET
            document.getElementById('platformDeviation').textContent = platformDeviation.toFixed(2) + 'mm'
            
            // Color code based on precision
            const platformEl = document.getElementById('platformDeviation')
            
            // Doctors are proud of sub-millimeter precision
            if (platformDeviation < 1) {
                platformEl.className = 'metric-value good'
            } else if (platformDeviation < 3) {
                platformEl.className = 'metric-value warning'
            } else {
                platformEl.className = 'metric-value bad'
            }
            
            // Update laser color based on precision
            if (drillLaser) {
                if (platformDeviation < 1) {
                    drillLaser.material.color.setHex(0x00ff00) // Green when close
                } else if (platformDeviation < 3) {
                    drillLaser.material.color.setHex(0xffaa00) // Orange when medium
                } else {
                    drillLaser.material.color.setHex(0xff0000) // Red when far
                }
            }
        }
        
        // Start placement
        document.addEventListener('click', () => {
            if (!isPlacing) {
                startPlacement()
            } else {
                endPlacement()
            }
        })
        
        function startPlacement() {
            isPlacing = true
            startTime = Date.now()
            document.getElementById('instructionText').textContent = 'Position the drill and click to place'
            
            // Start session tracking
            const mode = tutorialMode ? 'tutorial' : currentMode
            startSession(currentMethod, mode)
            
            // Start timer
            const interval = setInterval(() => {
                if (isPlacing) {
                    const elapsed = (Date.now() - startTime) / 1000
                    document.getElementById('timeElapsed').textContent = elapsed.toFixed(1) + 's'
                } else {
                    clearInterval(interval)
                }
            }, 100)
        }
        
        function endPlacement() {
            isPlacing = false
            
            if (currentMode === 'explore') {
                // In explore mode, just reset position
                document.getElementById('instructionText').textContent = 'Nice exploration! Try another method'
                setTimeout(() => {
                    drillGroup.position.set(0, 3, 0)
                }, 1000)
                return
            }
            
            // Challenge mode scoring
            const finalTime = ((Date.now() - startTime) / 1000).toFixed(1)
            
            // Calculate score based on DRILL TIP distance from target
            const drillTipWorld = new THREE.Vector3(
                drillGroup.position.x,
                drillGroup.position.y - 2, // Tip is 2 units below drill center
                drillGroup.position.z
            )
            
            // Get 2D distance (ignoring height) from drill tip to target
            const distance2D = Math.sqrt(
                Math.pow(drillTipWorld.x - targetPosition.x, 2) +
                Math.pow(drillTipWorld.z - targetPosition.z, 2)
            )
            
            const platformDeviation = distance2D * 10 // Convert to mm
            
            // Scoring: Doctors are proud of precision
            let score
            if (platformDeviation < 0.5) {
                score = 100 // Perfect - sub 0.5mm
            } else if (platformDeviation < 1) {
                score = 95 // Excellent - sub 1mm
            } else if (platformDeviation < 2) {
                score = 85 // Good - sub 2mm
            } else if (platformDeviation < 3) {
                score = 70 // Acceptable - sub 3mm
            } else if (platformDeviation < 5) {
                score = 50 // Poor - 3-5mm off
            } else {
                score = Math.max(10, 50 - (platformDeviation - 5) * 5) // Very poor
            }
            
            // Show score popup
            showScorePopup(score)
            
            // Show results after delay
            setTimeout(() => {
                showResults(score, finalTime, platformDeviation)
            }, 1500)
        }
        
        function showScorePopup(score) {
            const popup = document.createElement('div')
            popup.className = 'score-popup'
            popup.textContent = score + '%'
            popup.style.color = score > 90 ? '#00ff88' : score > 70 ? '#ffaa00' : '#ff4444'
            popup.style.left = '50%'
            popup.style.top = '50%'
            document.body.appendChild(popup)
            
            setTimeout(() => popup.remove(), 2000)
        }
        
        function showResults(score, time, platformDeviation) {
            if (tutorialMode) {
                // Store score AND precision for comparison
                methodScores[currentMethod] = {
                    score: score,
                    precision: platformDeviation
                }
                
                // Show tutorial-specific results
                if (tutorialStep < 3) {
                    // Show intermediate tutorial message
                    showTutorialProgress(score, platformDeviation, currentMethod)
                    return
                } else {
                    // Show final comparison after Yomi
                    showTutorialComparison()
                    return
                }
            }
            
            // Normal results display
            document.getElementById('scoreDisplay').textContent = score + '%'
            document.getElementById('scoreDisplay').style.color = 
                score > 90 ? '#00ff88' : score > 70 ? '#ffaa00' : '#ff4444'
            
            document.getElementById('methodResult').textContent = 
                currentMethod.charAt(0).toUpperCase() + currentMethod.slice(1)
            document.getElementById('precisionResult').textContent = platformDeviation.toFixed(2) + 'mm'
            document.getElementById('timeResult').textContent = time + 's'
            
            document.getElementById('resultsModal').style.display = 'flex'
        }

        function showTutorialProgress(score, precision, method) {
            const messages = {
                freehand: `Freehand Result: ${precision.toFixed(1)}mm off target\n\nAs you experienced, freehand surgery is extremely challenging. Even skilled surgeons struggle to achieve sub-millimeter precision with natural hand tremors.\n\nLet's see how a static guide improves this...`,
                static: `Static Guide Result: ${precision.toFixed(1)}mm off target\n\nBetter than freehand! The guide helps, but achieving consistent sub-millimeter precision still requires exceptional skill.\n\nNow let's experience Yomi's robotic precision...`
            }
            
            alert(messages[method])
            
            // Progress to next step
            tutorialStep++
            if (tutorialStep === 2) {
                setMethodForTutorial('static')
            } else if (tutorialStep === 3) {
                setMethodForTutorial('yomi')
            }
            updateTutorialUI()
            tryAgain()
        }

        function showTutorialComparison() {
            const comparison = `Tutorial Complete! Your precision results:

Freehand: ${methodScores.freehand.precision.toFixed(1)}mm off target
Static Guide: ${methodScores.static.precision.toFixed(1)}mm off target
Yomi Robot: ${methodScores.yomi.precision.toFixed(1)}mm off target

${methodScores.yomi.precision < 1 ? 
    "Exceptional! Yomi achieved sub-millimeter precision!" : 
    "Yomi's robotic guidance dramatically improves precision!"}

Doctors using Yomi consistently achieve <1mm precision - the gold standard in implant surgery.`
            
            alert(comparison)
            tutorialMode = false
            document.getElementById('instructionText').textContent = "Tutorial complete! Try any method again"
            document.getElementById('controlsText').textContent = "You can now freely switch between methods"
            tryAgain()
        }
        
        window.tryAgain = () => {
            document.getElementById('resultsModal').style.display = 'none'
            drillGroup.position.set(0, 3, 0)
            document.getElementById('instructionText').textContent = 'Select a method and click to begin placement'
        }
        
        // Track session start
        let currentSessionId = null
        
        async function startSession(method, mode) {
            try {
                const { data: { user } } = await supabase.auth.getUser()
                if (user) {
                    const { data, error } = await supabase
                        .from('sessions')
                        .insert({
                            user_id: user.id,
                            method: method,
                            mode: mode,
                            browser_info: {
                                userAgent: navigator.userAgent,
                                platform: navigator.platform,
                                language: navigator.language
                            }
                        })
                        .select()
                        .single()
                    
                    if (!error && data) {
                        currentSessionId = data.id
                        console.log('Session started:', currentSessionId)
                    }
                }
            } catch (error) {
                console.error('Error starting session:', error)
            }
        }
        
        async function completeSession(score, precisionMM, timeSeconds) {
            if (!currentSessionId) return
            
            try {
                const { error } = await supabase
                    .from('sessions')
                    .update({
                        completed_at: new Date().toISOString(),
                        score: score,
                        precision_mm: precisionMM,
                        time_seconds: timeSeconds
                    })
                    .eq('id', currentSessionId)
                
                if (!error) {
                    console.log('Session completed:', currentSessionId)
                }
            } catch (error) {
                console.error('Error completing session:', error)
            }
        }
        
        window.saveResults = async () => {
            try {
                const { data: { user } } = await supabase.auth.getUser()
                if (user) {
                    const score = parseInt(document.getElementById('scoreDisplay').textContent)
                    const method = document.getElementById('methodResult').textContent.toLowerCase()
                    const precisionText = document.getElementById('precisionResult').textContent
                    const precision = parseFloat(precisionText.replace('mm', ''))
                    const timeText = document.getElementById('timeResult').textContent
                    const time = parseFloat(timeText.replace('s', ''))
                    
                    // Complete the session
                    await completeSession(score, precision, time)
                    
                    alert('Results saved successfully!')
                }
            } catch (error) {
                console.error('Save error:', error)
                alert('Error saving results')
            }
            tryAgain()
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate)
            
            controls.update()
            
            // Animate target elements
            if (targetGroup && isPlacing) {
                // Calculate current distance from drill tip
                const drillTipWorld = new THREE.Vector3(
                    drillGroup.position.x,
                    drillGroup.position.y - 2,
                    drillGroup.position.z
                )
                const distance2D = Math.sqrt(
                    Math.pow(drillTipWorld.x - targetPosition.x, 2) +
                    Math.pow(drillTipWorld.z - targetPosition.z, 2)
                )
                const distanceMM = distance2D * 10
                
                // When within 1mm, make everything glow bright green
                if (distanceMM < 1) {
                    targetMarker.material.color.setHex(0x00ff00)
                    targetMarker.material.opacity = 0.9
                    centerMarker.material.color.setHex(0x00ff00)
                    centerMarker.material.emissive.setHex(0x00ff00)
                    centerMarker.material.emissiveIntensity = 5
                    pulseRing.material.color.setHex(0x00ff00)
                    pulseRing.material.opacity = 0.6
                    pulseRing.scale.setScalar(1.5 + Math.sin(Date.now() * 0.01) * 0.2)
                    
                    // Make arrow glow too
                    arrow.material.color.setHex(0x00ff00)
                    arrow.material.opacity = 1
                    
                    // Update text to show success
                    if (sprite.material.map) {
                        const canvas = document.createElement('canvas')
                        canvas.width = 256
                        canvas.height = 64
                        const ctx = canvas.getContext('2d')
                        ctx.fillStyle = '#00ff00'
                        ctx.font = 'bold 32px Arial'
                        ctx.textAlign = 'center'
                        ctx.fillText('PERFECT!', 128, 40)
                        sprite.material.map = new THREE.CanvasTexture(canvas)
                        sprite.material.map.needsUpdate = true
                    }
                } else {
                    // Normal animation
                    targetMarker.material.color.setHex(0x00ff88)
                    targetMarker.material.opacity = 0.6 + Math.sin(Date.now() * 0.003) * 0.2
                    centerMarker.material.color.setHex(0x00ff88)
                    centerMarker.material.emissive.setHex(0x00ff88)
                    centerMarker.material.emissiveIntensity = 2
                    pulseRing.material.color.setHex(0x00ff88)
                    pulseRing.material.opacity = 0.2 + Math.sin(Date.now() * 0.002) * 0.1
                    pulseRing.scale.setScalar(1 + Math.sin(Date.now() * 0.002) * 0.1)
                    arrow.material.color.setHex(0x00ff88)
                    arrow.material.opacity = 0.7
                }
                
                // Bob the arrow
                arrow.position.y = 1.5 + Math.sin(Date.now() * 0.004) * 0.2
                
                // Rotate the center marker
                centerMarker.rotation.y += 0.02
                
                // Float the text
                sprite.position.y = 2 + Math.sin(Date.now() * 0.003) * 0.1
            }
            
            // Rotate drill when placing
            if (isPlacing) {
                drillGroup.rotation.y += 0.05
                
                // Pulse the tip indicator
                if (drillTip) {
                    drillTip.material.opacity = 0.6 + Math.sin(Date.now() * 0.01) * 0.3
                }
            }
            
            renderer.render(scene, camera)
        }
        animate()
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
        })
        
        // Hide cursor
        document.body.style.cursor = 'none'
        
        } // End of initializeSimulation
    </script>
</body>
</html>