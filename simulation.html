<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TryYomi - Precision Surgery Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* HUD */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 100;
        }

        .hud > * {
            pointer-events: auto;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 20px;
            padding: 20px;
            min-width: 200px;
        }

        .method-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .method-title {
            font-size: 14px;
            color: #888;
            margin-bottom: 5px;
        }

        .method-btn {
            padding: 12px 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .method-btn.active {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            color: #00ff88;
        }

        .method-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        /* Metrics */
        .metrics {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metric-label {
            font-size: 14px;
            color: #888;
        }

        .metric-value {
            font-size: 20px;
            font-weight: 600;
        }

        .metric-value.good {
            color: #00ff88;
        }

        .metric-value.warning {
            color: #ffaa00;
        }

        .metric-value.bad {
            color: #ff4444;
        }

        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 15px;
            padding: 20px 40px;
            text-align: center;
            z-index: 100;
        }

        .instruction-text {
            font-size: 16px;
            color: #00ff88;
            margin-bottom: 10px;
        }

        .controls {
            font-size: 14px;
            color: #888;
        }

        /* Target indicator */
        .target-indicator {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
            display: none; /* Hide screen target, we'll use 3D target */
        }

        .target-ring {
            position: absolute;
            border: 2px solid #00ff88;
            border-radius: 50%;
            opacity: 0.5;
            animation: pulse 2s ease-in-out infinite;
        }

        .ring-1 {
            width: 100px;
            height: 100px;
            left: -50px;
            top: -50px;
        }

        .ring-2 {
            width: 60px;
            height: 60px;
            left: -30px;
            top: -30px;
            animation-delay: 0.5s;
        }

        .ring-3 {
            width: 20px;
            height: 20px;
            left: -10px;
            top: -10px;
            animation-delay: 1s;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 0.5;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
        }

        /* Timer */
        .timer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: 700;
            color: #00ff88;
            opacity: 0;
            pointer-events: none;
            z-index: 200;
            text-shadow: 0 0 50px rgba(0, 255, 136, 0.5);
        }

        .timer.show {
            animation: timerPulse 1s ease-out;
        }

        @keyframes timerPulse {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.2);
            }
        }

        /* Tutorial overlay */
        .tutorial-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }

        .tutorial-overlay.hidden {
            display: none;
        }

        .tutorial-content {
            background: linear-gradient(135deg, #0a0f1b 0%, #1a1f2e 100%);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 30px;
            padding: 50px;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .tutorial-title {
            font-size: 32px;
            font-weight: 700;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
        }

        .tutorial-desc {
            font-size: 18px;
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 40px;
        }

        .tutorial-steps {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 40px;
        }

        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            opacity: 0.5;
            transition: all 0.3s ease;
        }

        .step.active {
            opacity: 1;
        }

        .step-number {
            width: 50px;
            height: 50px;
            border: 2px solid #444;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: 700;
            background: rgba(255, 255, 255, 0.05);
        }

        .step.active .step-number {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
        }

        .step-label {
            font-size: 14px;
            color: #888;
        }

        .step.active .step-label {
            color: #00ff88;
        }

        /* Results modal */
        .results-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .results-content {
            background: linear-gradient(135deg, #0a0f1b 0%, #1a1f2e 100%);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 30px;
            padding: 50px;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        .results-title {
            font-size: 36px;
            font-weight: 700;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
        }

        .score-display {
            font-size: 72px;
            font-weight: 800;
            margin-bottom: 20px;
        }

        .score-breakdown {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .breakdown-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
        }

        .breakdown-label {
            font-size: 14px;
            color: #888;
            margin-bottom: 5px;
        }

        .breakdown-value {
            font-size: 24px;
            font-weight: 600;
        }

        .action-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: black;
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid #00ff88;
            color: #00ff88;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        /* Precision cursor */
        .precision-cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 2px solid #00ff88;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
        }

        .precision-cursor.freehand {
            animation: shake 0.15s infinite;
            border-color: #ff4444;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
        }

        .precision-cursor.static {
            animation: shake 0.3s infinite;
            border-color: #ffaa00;
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.6);
        }

        .precision-cursor.yomi {
            animation: none;
            border-color: #00ff88;
            box-shadow: 0 0 30px rgba(0, 255, 136, 1);
            border-width: 3px;
        }

        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            10% { transform: translate(-45%, -55%) rotate(2deg); }
            20% { transform: translate(-55%, -45%) rotate(-2deg); }
            30% { transform: translate(-52%, -53%) rotate(1deg); }
            40% { transform: translate(-48%, -47%) rotate(-1deg); }
            50% { transform: translate(-53%, -50%) rotate(3deg); }
            60% { transform: translate(-47%, -52%) rotate(-3deg); }
            70% { transform: translate(-51%, -48%) rotate(2deg); }
            80% { transform: translate(-49%, -54%) rotate(-1deg); }
            90% { transform: translate(-54%, -46%) rotate(1deg); }
        }

        /* Score animation */
        .score-popup {
            position: fixed;
            font-size: 48px;
            font-weight: 700;
            pointer-events: none;
            z-index: 200;
            animation: scoreFloat 2s ease-out forwards;
        }

        @keyframes scoreFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) scale(1.5);
            }
        }
    </style>
    <!-- Configuration -->
    <script src="config.js"></script>
    <!-- Google Analytics -->
    <script async id="ga-script"></script>
    <script>
        // Load GA script with configured ID
        document.getElementById('ga-script').src = `https://www.googletagmanager.com/gtag/js?id=${CONFIG.GA_MEASUREMENT_ID}`;
        
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', CONFIG.GA_MEASUREMENT_ID);
    </script>
</head>
<body>
    <!-- Auth check overlay -->
    <div id="authCheck" style="position: fixed; inset: 0; background: #000; z-index: 9999; display: flex; align-items: center; justify-content: center;">
        <div style="text-align: center;">
            <h2 style="color: #00ff88; font-size: 24px; margin-bottom: 20px;">Checking authentication...</h2>
            <div class="loading" style="margin: 0 auto; width: 40px; height: 40px; border: 3px solid rgba(0, 255, 136, 0.3); border-radius: 50%; border-top-color: #00ff88; animation: spin 1s ease-in-out infinite;"></div>
        </div>
    </div>
    
    <style>
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
    
    <canvas id="canvas"></canvas>
    
    <!-- Custom cursor -->
    <div class="precision-cursor" id="cursor"></div>
    
    <!-- HUD -->
    <div class="hud">
        <div class="hud-panel">
            <div class="method-selector">
                <div class="method-title">SURGICAL METHOD</div>
                <button class="method-btn active" onclick="setMethod('freehand')">Freehand</button>
                <button class="method-btn" onclick="setMethod('static')">Static Guided</button>
                <button class="method-btn" onclick="setMethod('yomi')">Yomi Robotic</button>
            </div>
        </div>
        
        <div class="hud-panel">
            <div class="metrics">
                <div class="metric">
                    <span class="metric-label">Distance from Target</span>
                    <span class="metric-value" id="platformDeviation">0.00mm</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Precision Goal</span>
                    <span class="metric-value good">&lt;1mm</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Time Elapsed</span>
                    <span class="metric-value" id="timeElapsed">0.0s</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Target indicator -->
    <div class="target-indicator" id="targetIndicator">
        <div class="target-ring ring-1"></div>
        <div class="target-ring ring-2"></div>
        <div class="target-ring ring-3"></div>
    </div>
    
    <!-- Instructions -->
    <div class="instructions">
        <div class="instruction-text" id="instructionText">Welcome! Let's explore how surgical precision improves with technology</div>
        <div class="controls" id="controlsText">We'll start with freehand surgery to see the challenges</div>
    </div>
    
    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-content">
            <h2 class="tutorial-title" id="tutorialTitle">Welcome to Precision Surgery Training</h2>
            <p class="tutorial-desc" id="tutorialDesc">
                You'll experience three different surgical methods, from most challenging to easiest.
                Watch how technology dramatically improves precision and reduces surgeon fatigue.
            </p>
            <div class="tutorial-steps">
                <div class="step active" id="step1">
                    <div class="step-number">1</div>
                    <div class="step-label">Freehand</div>
                </div>
                <div class="step" id="step2">
                    <div class="step-number">2</div>
                    <div class="step-label">Static Guide</div>
                </div>
                <div class="step" id="step3">
                    <div class="step-number">3</div>
                    <div class="step-label">Yomi Robot</div>
                </div>
            </div>
            <button class="btn btn-primary" onclick="startTutorial()">Start Tutorial</button>
        </div>
    </div>
    
    <!-- Timer -->
    <div class="timer" id="timer">3</div>
    
    <!-- Results Modal -->
    <div class="results-modal" id="resultsModal">
        <div class="results-content">
            <h2 class="results-title">Procedure Complete!</h2>
            <div class="score-display" id="scoreDisplay">95%</div>
            
            <div class="score-breakdown">
                <div class="breakdown-item">
                    <div class="breakdown-label">Method</div>
                    <div class="breakdown-value" id="methodResult">Freehand</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-label">Precision</div>
                    <div class="breakdown-value" id="precisionResult">0.5mm</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-label">Time</div>
                    <div class="breakdown-value" id="timeResult">12.3s</div>
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="btn btn-primary" onclick="tryAgain()">Try Again</button>
                <button class="btn btn-secondary" onclick="saveResults()">Save Results</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three'
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm'
        
        // Supabase configuration from config.js
        const supabase = createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY)
        
        // Check authentication
        async function checkAuth() {
            console.log('Checking authentication...')
            
            // Add timeout for auth check
            const timeoutPromise = new Promise((resolve, reject) => {
                setTimeout(() => reject(new Error('Auth check timeout')), 5000)
            })
            
            const authPromise = (async () => {
                const { data: { user }, error } = await supabase.auth.getUser()
                
                if (error) {
                    console.error('Auth error:', error)
                    throw error
                }
                
                if (!user) {
                    // Not authenticated, redirect to home
                    console.log('No user found, redirecting...')
                    alert('Please sign in to use the simulator')
                    window.location.href = 'index.html'
                    return false
                }
                
                console.log('User authenticated:', user.email)
                // Hide auth check overlay
                document.getElementById('authCheck').style.display = 'none'
                return true
            })()
            
            try {
                return await Promise.race([authPromise, timeoutPromise])
            } catch (error) {
                console.error('Auth check failed:', error)
                alert('Authentication check failed. Redirecting to home page.')
                window.location.href = 'index.html'
                return false
            }
        }
        
        // Wait for config to load then check auth
        setTimeout(() => {
            if (typeof CONFIG === 'undefined') {
                console.error('CONFIG not loaded! Check config.js')
                alert('Configuration failed to load. Please refresh the page.')
                document.getElementById('authCheck').innerHTML = '<div style="text-align: center; color: #ff4444;"><h2>Configuration Error</h2><p>Please refresh the page</p></div>'
            } else {
                // Only initialize the game if authenticated
                checkAuth().then(isAuthenticated => {
                    if (isAuthenticated) {
                        initializeSimulation()
                    }
                }).catch(err => {
                    console.error('Auth check promise failed:', err)
                })
            }
        }, 100) // Small delay to ensure config.js loads
        
        function initializeSimulation() {
        
        // Scene setup
        const scene = new THREE.Scene()
        scene.fog = new THREE.Fog(0x000000, 10, 50)
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.set(0, 5, 8)
        
        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('canvas'),
            antialias: true,
            alpha: false
        })
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFSoftShadowMap
        renderer.toneMapping = THREE.ACESFilmicToneMapping
        renderer.toneMappingExposure = 1.2
        
        // Controls
        const controls = new OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true
        controls.dampingFactor = 0.05
        controls.maxPolarAngle = Math.PI / 2.2
        controls.minDistance = 5
        controls.maxDistance = 15
        controls.target.set(0, 0, 0)
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5)
        scene.add(ambientLight)
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 1)
        mainLight.position.set(5, 10, 5)
        mainLight.castShadow = true
        mainLight.shadow.camera.near = 0.1
        mainLight.shadow.camera.far = 50
        mainLight.shadow.camera.left = -10
        mainLight.shadow.camera.right = 10
        mainLight.shadow.camera.top = 10
        mainLight.shadow.camera.bottom = -10
        mainLight.shadow.mapSize.width = 2048
        mainLight.shadow.mapSize.height = 2048
        scene.add(mainLight)
        
        const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3)
        fillLight.position.set(-5, 5, -5)
        scene.add(fillLight)
        
        // Create realistic jaw
        const jawGroup = new THREE.Group()
        
        // Jaw bone
        const jawGeometry = new THREE.TorusGeometry(3.5, 1.5, 24, 48, Math.PI)
        const jawMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xFFE4E1,
            roughness: 0.8,
            metalness: 0,
            clearcoat: 0.2,
            clearcoatRoughness: 0.9,
            bumpScale: 0.002,
        })
        
        const jaw = new THREE.Mesh(jawGeometry, jawMaterial)
        jaw.rotation.x = -Math.PI / 2
        jaw.castShadow = true
        jaw.receiveShadow = true
        jawGroup.add(jaw)
        
        // Gum tissue
        const gumGeometry = new THREE.TorusGeometry(3.3, 1.4, 24, 48, Math.PI)
        const gumMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xFFB5C5,
            roughness: 0.9,
            metalness: 0,
            clearcoat: 0.1,
            transmission: 0.1,
            thickness: 0.5,
        })
        
        const gum = new THREE.Mesh(gumGeometry, gumMaterial)
        gum.rotation.x = -Math.PI / 2
        gum.position.y = 0.1
        gum.castShadow = true
        gum.receiveShadow = true
        jawGroup.add(gum)
        
        // Create realistic teeth
        const teethGroup = new THREE.Group()
        
        function createTooth(type = 'molar') {
            let geometry
            if (type === 'molar') {
                geometry = new THREE.CylinderGeometry(0.35, 0.3, 1, 12)
            } else if (type === 'premolar') {
                geometry = new THREE.CylinderGeometry(0.3, 0.25, 1.1, 10)
            } else {
                geometry = new THREE.CylinderGeometry(0.25, 0.2, 1.2, 8)
            }
            
            // Add some realistic deformation
            const positions = geometry.attributes.position
            for (let i = 0; i < positions.count; i++) {
                const y = positions.getY(i)
                if (y > 0) {
                    const noise = (Math.random() - 0.5) * 0.05
                    positions.setX(i, positions.getX(i) + noise)
                    positions.setZ(i, positions.getZ(i) + noise)
                }
            }
            
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xFFFFF0,
                roughness: 0.2,
                metalness: 0,
                clearcoat: 1,
                clearcoatRoughness: 0.05,
                reflectivity: 0.5,
                envMapIntensity: 1,
                sheen: 0.5,
                sheenRoughness: 0.2,
                sheenColor: 0xffffff,
            })
            
            const tooth = new THREE.Mesh(geometry, material)
            tooth.castShadow = true
            tooth.receiveShadow = true
            
            return tooth
        }
        
        // Place teeth realistically
        const teethPositions = [
            { angle: 0.1, radius: 3.2, type: 'incisor' },
            { angle: 0.3, radius: 3.2, type: 'incisor' },
            { angle: 0.5, radius: 3.2, type: 'canine' },
            { angle: 0.7, radius: 3.1, type: 'premolar' },
            { angle: 0.9, radius: 3.0, type: 'premolar' },
            { angle: 1.1, radius: 2.9, type: 'molar' },
            { angle: 1.3, radius: 2.8, type: 'molar' },
            { angle: 1.8, radius: 2.8, type: 'molar' },
            { angle: 2.0, radius: 2.9, type: 'molar' },
            { angle: 2.2, radius: 3.0, type: 'premolar' },
            { angle: 2.4, radius: 3.1, type: 'premolar' },
            { angle: 2.6, radius: 3.2, type: 'canine' },
            { angle: 2.8, radius: 3.2, type: 'incisor' },
            { angle: 3.0, radius: 3.2, type: 'incisor' },
        ]
        
        teethPositions.forEach((pos, index) => {
            const tooth = createTooth(pos.type)
            tooth.position.x = Math.cos(pos.angle) * pos.radius
            tooth.position.z = Math.sin(pos.angle) * pos.radius
            tooth.position.y = 0.6
            tooth.rotation.z = (Math.random() - 0.5) * 0.1
            tooth.rotation.x = (Math.random() - 0.5) * 0.05
            
            // Skip one tooth for implant site
            if (index !== 7) {
                teethGroup.add(tooth)
            }
        })
        
        jawGroup.add(teethGroup)
        scene.add(jawGroup)
        
        // Target site marker - MUCH MORE VISIBLE
        const targetGroup = new THREE.Group()
        
        // Main target ring
        const targetGeometry = new THREE.RingGeometry(0.35, 0.45, 32)
        const targetMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        })
        const targetMarker = new THREE.Mesh(targetGeometry, targetMaterial)
        targetMarker.rotation.x = -Math.PI / 2
        targetGroup.add(targetMarker)
        
        // Glowing center point
        const centerGeometry = new THREE.SphereGeometry(0.1, 16, 16)
        const centerMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            emissive: 0x00ff88,
            emissiveIntensity: 2
        })
        const centerMarker = new THREE.Mesh(centerGeometry, centerMaterial)
        centerMarker.position.y = 0.05
        targetGroup.add(centerMarker)
        
        // Outer pulse ring
        const pulseGeometry = new THREE.RingGeometry(0.5, 0.6, 32)
        const pulseMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        })
        const pulseRing = new THREE.Mesh(pulseGeometry, pulseMaterial)
        pulseRing.rotation.x = -Math.PI / 2
        targetGroup.add(pulseRing)
        
        // Arrow pointing down
        const arrowGeometry = new THREE.ConeGeometry(0.2, 0.5, 8)
        const arrowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.7
        })
        const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial)
        arrow.position.y = 1.5
        arrow.rotation.x = Math.PI
        targetGroup.add(arrow)
        
        // "TARGET HERE" text sprite
        const canvas = document.createElement('canvas')
        canvas.width = 256
        canvas.height = 64
        const ctx = canvas.getContext('2d')
        ctx.fillStyle = '#00ff88'
        ctx.font = 'bold 32px Arial'
        ctx.textAlign = 'center'
        ctx.fillText('TARGET HERE', 128, 40)
        
        const texture = new THREE.CanvasTexture(canvas)
        const spriteMaterial = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            opacity: 0.9
        })
        const sprite = new THREE.Sprite(spriteMaterial)
        sprite.position.y = 2
        sprite.scale.set(2, 0.5, 1)
        targetGroup.add(sprite)
        
        targetGroup.position.set(
            Math.cos(teethPositions[7].angle) * teethPositions[7].radius,
            0.61,
            Math.sin(teethPositions[7].angle) * teethPositions[7].radius
        )
        scene.add(targetGroup)
        
        const targetPosition = targetGroup.position.clone()
        
        // Drill/Implant model
        const drillGroup = new THREE.Group()
        
        // Drill body
        const drillBodyGeometry = new THREE.CylinderGeometry(0.15, 0.1, 3, 16)
        const drillBodyMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xE0E0E0,
            metalness: 0.9,
            roughness: 0.1,
            clearcoat: 1,
            clearcoatRoughness: 0.05,
        })
        const drillBody = new THREE.Mesh(drillBodyGeometry, drillBodyMaterial)
        drillGroup.add(drillBody)
        
        // Drill tip
        const drillTipGeometry = new THREE.ConeGeometry(0.1, 0.5, 8)
        const drillTip = new THREE.Mesh(drillTipGeometry, drillBodyMaterial)
        drillTip.position.y = -1.75
        drillGroup.add(drillTip)
        
        drillGroup.position.y = 3
        scene.add(drillGroup)
        
        // Game state
        let currentMethod = 'freehand'
        let isPlacing = false
        let startTime = 0
        let mouseX = 0, mouseY = 0
        let tutorialMode = true
        let tutorialStep = 1
        let methodScores = {
            freehand: null,
            static: null,
            yomi: null
        }
        
        const methodData = {
            freehand: {
                variance: 0.08,      // Much higher variance
                shake: 0.05,         // Very shaky
                drift: 0.03,         // Significant drift
                color: '#ff4444',
                description: 'Extremely difficult to achieve precision'
            },
            static: {
                variance: 0.025,     // Moderate variance
                shake: 0.015,        // Some shake
                drift: 0.008,        // Some drift
                color: '#ffaa00',
                description: 'Better than freehand, but still challenging'
            },
            yomi: {
                variance: 0.001,     // Almost no variance
                shake: 0.0002,       // Virtually no shake
                drift: 0,            // No drift at all
                color: '#00ff88',
                description: 'Robotic precision - consistently accurate'
            }
        }
        
        // Tutorial functions
        window.startTutorial = () => {
            document.getElementById('tutorialOverlay').classList.add('hidden')
            tutorialMode = true
            tutorialStep = 1
            setMethodForTutorial('freehand')
            updateTutorialUI()
        }

        function updateTutorialUI() {
            const tutorials = {
                1: {
                    title: "Step 1: Freehand Surgery",
                    instruction: "Click to start, then move your mouse to the GREEN TARGET and click to place",
                    controls: "Watch how difficult it is to hit the target - your hand naturally shakes!",
                    method: 'freehand'
                },
                2: {
                    title: "Step 2: Static Guided Surgery",
                    instruction: "Click to start, then guide the drill to the GREEN TARGET",
                    controls: "Better than freehand, but still challenging to hit the exact center",
                    method: 'static'
                },
                3: {
                    title: "Step 3: Yomi Robotic Surgery",
                    instruction: "Click to start, then easily guide to the GREEN TARGET",
                    controls: "Notice how the robot stabilizes your movements - precision is effortless!",
                    method: 'yomi'
                }
            }

            const current = tutorials[tutorialStep]
            document.getElementById('instructionText').textContent = current.title
            document.getElementById('controlsText').textContent = current.instruction
            
            // Update step indicators
            document.querySelectorAll('.step').forEach((step, index) => {
                step.classList.toggle('active', index + 1 === tutorialStep)
            })
        }

        function setMethodForTutorial(method) {
            currentMethod = method
            
            // Update button states
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.classList.remove('active')
            })
            
            // Find and activate the correct button
            if (method === 'freehand') {
                document.querySelector('.method-btn:nth-child(1)').classList.add('active')
            } else if (method === 'static') {
                document.querySelector('.method-btn:nth-child(2)').classList.add('active')
            } else if (method === 'yomi') {
                document.querySelector('.method-btn:nth-child(3)').classList.add('active')
            }
            
            // Update cursor
            const cursor = document.getElementById('cursor')
            cursor.className = 'precision-cursor ' + method
        }

        // Method selection
        window.setMethod = (method) => {
            if (tutorialMode) return // Prevent manual switching during tutorial
            
            currentMethod = method
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.classList.remove('active')
            })
            event.target.classList.add('active')
            
            // Track method selection
            gtag('event', 'method_selected', {
                'method': method
            });
            
            // Update cursor class
            const cursor = document.getElementById('cursor')
            cursor.className = 'precision-cursor ' + method
            
            // Update instruction with emphasis on difficulty
            const methodNames = {
                freehand: 'Freehand - VERY DIFFICULT to achieve precision',
                static: 'Static Guided - Moderate difficulty',
                yomi: 'Yomi Robotic - EASY precision with robotic guidance'
            }
            document.getElementById('instructionText').textContent = 
                `${methodNames[method]} - Click to begin placement`
            
            // Update instruction text color based on method
            const instructionEl = document.getElementById('instructionText')
            instructionEl.style.color = methodData[method].color
        }
        
        // Mouse tracking
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1
            
            // Update cursor position
            const cursor = document.getElementById('cursor')
            cursor.style.left = event.clientX + 'px'
            cursor.style.top = event.clientY + 'px'
            
            if (isPlacing) {
                updateDrillPosition()
            }
        })
        
        function updateDrillPosition() {
            const raycaster = new THREE.Raycaster()
            raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera)
            
            // Create plane at jaw level
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0)
            const intersectPoint = new THREE.Vector3()
            raycaster.ray.intersectPlane(plane, intersectPoint)
            
            if (intersectPoint) {
                const method = methodData[currentMethod]
                
                // Add variance based on method
                const shakeX = (Math.random() - 0.5) * method.shake
                const shakeZ = (Math.random() - 0.5) * method.shake
                const shakeY = (Math.random() - 0.5) * method.shake * 0.5
                const drift = Math.sin(Date.now() * 0.001) * method.drift
                const driftY = Math.cos(Date.now() * 0.0015) * method.drift * 0.3
                
                drillGroup.position.x = intersectPoint.x + shakeX + drift
                drillGroup.position.z = intersectPoint.z + shakeZ
                drillGroup.position.y = 3 + shakeY + driftY
                
                // Add rotation shake for freehand
                if (currentMethod === 'freehand') {
                    drillGroup.rotation.x = (Math.random() - 0.5) * 0.1
                    drillGroup.rotation.z = (Math.random() - 0.5) * 0.1
                } else if (currentMethod === 'static') {
                    drillGroup.rotation.x = (Math.random() - 0.5) * 0.02
                    drillGroup.rotation.z = (Math.random() - 0.5) * 0.02
                } else {
                    drillGroup.rotation.x = 0
                    drillGroup.rotation.z = 0
                }
                
                // Update metrics
                updateMetrics()
            }
        }
        
        function updateMetrics() {
            const distance = drillGroup.position.distanceTo(targetPosition)
            const platformDeviation = distance * 10 // Convert to mm
            
            // Update UI - MAIN METRIC IS DISTANCE FROM TARGET
            document.getElementById('angleDeviation').textContent = '---'
            document.getElementById('platformDeviation').textContent = platformDeviation.toFixed(2) + 'mm'
            document.getElementById('depthAccuracy').textContent = '---'
            
            // Color code based on precision
            const platformEl = document.getElementById('platformDeviation')
            
            // Doctors are proud of sub-millimeter precision
            if (platformDeviation < 1) {
                platformEl.className = 'metric-value good'
            } else if (platformDeviation < 3) {
                platformEl.className = 'metric-value warning'
            } else {
                platformEl.className = 'metric-value bad'
            }
        }
        
        // Start placement
        document.addEventListener('click', () => {
            if (!isPlacing) {
                startPlacement()
            } else {
                endPlacement()
            }
        })
        
        function startPlacement() {
            isPlacing = true
            startTime = Date.now()
            document.getElementById('instructionText').textContent = 'Position the drill and click to place'
            
            // Start timer
            const interval = setInterval(() => {
                if (isPlacing) {
                    const elapsed = (Date.now() - startTime) / 1000
                    document.getElementById('timeElapsed').textContent = elapsed.toFixed(1) + 's'
                } else {
                    clearInterval(interval)
                }
            }, 100)
        }
        
        function endPlacement() {
            isPlacing = false
            const finalTime = ((Date.now() - startTime) / 1000).toFixed(1)
            
            // Calculate score based ONLY on distance from target
            const distance = drillGroup.position.distanceTo(targetPosition)
            const platformDeviation = distance * 10 // Convert to mm
            
            // Scoring: Doctors are proud of precision
            let score
            if (platformDeviation < 0.5) {
                score = 100 // Perfect - sub 0.5mm
            } else if (platformDeviation < 1) {
                score = 95 // Excellent - sub 1mm
            } else if (platformDeviation < 2) {
                score = 85 // Good - sub 2mm
            } else if (platformDeviation < 3) {
                score = 70 // Acceptable - sub 3mm
            } else if (platformDeviation < 5) {
                score = 50 // Poor - 3-5mm off
            } else {
                score = Math.max(10, 50 - (platformDeviation - 5) * 5) // Very poor
            }
            
            // Show score popup
            showScorePopup(score)
            
            // Show results after delay
            setTimeout(() => {
                showResults(score, finalTime, platformDeviation)
            }, 1500)
        }
        
        function showScorePopup(score) {
            const popup = document.createElement('div')
            popup.className = 'score-popup'
            popup.textContent = score + '%'
            popup.style.color = score > 90 ? '#00ff88' : score > 70 ? '#ffaa00' : '#ff4444'
            popup.style.left = '50%'
            popup.style.top = '50%'
            document.body.appendChild(popup)
            
            setTimeout(() => popup.remove(), 2000)
        }
        
        function showResults(score, time, platformDeviation) {
            if (tutorialMode) {
                // Store score AND precision for comparison
                methodScores[currentMethod] = {
                    score: score,
                    precision: platformDeviation
                }
                
                // Show tutorial-specific results
                if (tutorialStep < 3) {
                    // Show intermediate tutorial message
                    showTutorialProgress(score, platformDeviation, currentMethod)
                    return
                } else {
                    // Show final comparison after Yomi
                    showTutorialComparison()
                    return
                }
            }
            
            // Normal results display
            document.getElementById('scoreDisplay').textContent = score + '%'
            document.getElementById('scoreDisplay').style.color = 
                score > 90 ? '#00ff88' : score > 70 ? '#ffaa00' : '#ff4444'
            
            document.getElementById('methodResult').textContent = 
                currentMethod.charAt(0).toUpperCase() + currentMethod.slice(1)
            document.getElementById('precisionResult').textContent = platformDeviation.toFixed(2) + 'mm'
            document.getElementById('timeResult').textContent = time + 's'
            
            document.getElementById('resultsModal').style.display = 'flex'
        }

        function showTutorialProgress(score, precision, method) {
            const messages = {
                freehand: `Freehand Result: ${precision.toFixed(1)}mm off target\n\nAs you experienced, freehand surgery is extremely challenging. Even skilled surgeons struggle to achieve sub-millimeter precision with natural hand tremors.\n\nLet's see how a static guide improves this...`,
                static: `Static Guide Result: ${precision.toFixed(1)}mm off target\n\nBetter than freehand! The guide helps, but achieving consistent sub-millimeter precision still requires exceptional skill.\n\nNow let's experience Yomi's robotic precision...`
            }
            
            alert(messages[method])
            
            // Progress to next step
            tutorialStep++
            if (tutorialStep === 2) {
                setMethodForTutorial('static')
            } else if (tutorialStep === 3) {
                setMethodForTutorial('yomi')
            }
            updateTutorialUI()
            tryAgain()
        }

        function showTutorialComparison() {
            const comparison = `Tutorial Complete! Your precision results:

Freehand: ${methodScores.freehand.precision.toFixed(1)}mm off target
Static Guide: ${methodScores.static.precision.toFixed(1)}mm off target
Yomi Robot: ${methodScores.yomi.precision.toFixed(1)}mm off target

${methodScores.yomi.precision < 1 ? 
    "Exceptional! Yomi achieved sub-millimeter precision!" : 
    "Yomi's robotic guidance dramatically improves precision!"}

Doctors using Yomi consistently achieve <1mm precision - the gold standard in implant surgery.`
            
            alert(comparison)
            tutorialMode = false
            document.getElementById('instructionText').textContent = "Tutorial complete! Try any method again"
            document.getElementById('controlsText').textContent = "You can now freely switch between methods"
            tryAgain()
        }
        
        window.tryAgain = () => {
            document.getElementById('resultsModal').style.display = 'none'
            drillGroup.position.set(0, 3, 0)
            document.getElementById('instructionText').textContent = 'Select a method and click to begin placement'
        }
        
        window.saveResults = async () => {
            try {
                const { data: { user } } = await supabase.auth.getUser()
                if (user) {
                    const score = parseInt(document.getElementById('scoreDisplay').textContent)
                    const method = document.getElementById('methodResult').textContent
                    const precision = document.getElementById('precisionResult').textContent
                    const time = document.getElementById('timeResult').textContent
                    
                    // Save to Supabase (you'll need to create a 'scores' table)
                    const { error } = await supabase
                        .from('scores')
                        .insert({
                            user_id: user.id,
                            score: score,
                            method: method,
                            precision: precision,
                            time: time,
                            created_at: new Date().toISOString()
                        })
                    
                    if (error) {
                        console.error('Error saving results:', error)
                        alert('Results saved locally')
                    } else {
                        alert('Results saved successfully!')
                    }
                }
            } catch (error) {
                console.error('Save error:', error)
            }
            tryAgain()
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate)
            
            controls.update()
            
            // Animate target elements
            if (targetGroup) {
                // Pulse the rings
                targetMarker.material.opacity = 0.6 + Math.sin(Date.now() * 0.003) * 0.2
                pulseRing.material.opacity = 0.2 + Math.sin(Date.now() * 0.002) * 0.1
                pulseRing.scale.setScalar(1 + Math.sin(Date.now() * 0.002) * 0.1)
                
                // Bob the arrow
                arrow.position.y = 1.5 + Math.sin(Date.now() * 0.004) * 0.2
                
                // Rotate the center marker
                centerMarker.rotation.y += 0.02
                
                // Float the text
                sprite.position.y = 2 + Math.sin(Date.now() * 0.003) * 0.1
            }
            
            // Rotate drill when placing
            if (isPlacing) {
                drillGroup.rotation.y += 0.05
            }
            
            renderer.render(scene, camera)
        }
        animate()
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
        })
        
        // Hide cursor
        document.body.style.cursor = 'none'
        
        } // End of initializeSimulation
    </script>
</body>
</html>